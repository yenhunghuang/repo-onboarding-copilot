// Package analysis provides vulnerability analysis helper functions
package analysis

import (
	"fmt"
	"sort"
)

// generateSecurityRecommendations creates security recommendations based on vulnerability analysis
func (da *DependencyAnalyzer) generateSecurityRecommendations(vulnerabilities []Vulnerability, alerts []*VulnerabilityAlert) []string {
	var recommendations []string

	// Count vulnerabilities by severity
	severityCounts := make(map[string]int)
	for _, vuln := range vulnerabilities {
		severityCounts[vuln.Severity]++
	}

	// Critical vulnerabilities recommendations
	if severityCounts["critical"] > 0 {
		recommendations = append(recommendations, 
			fmt.Sprintf("IMMEDIATE ACTION REQUIRED: %d critical vulnerabilities found. Review and patch immediately.", severityCounts["critical"]))
	}

	// High severity recommendations
	if severityCounts["high"] > 0 {
		recommendations = append(recommendations, 
			fmt.Sprintf("HIGH PRIORITY: %d high-severity vulnerabilities require urgent attention.", severityCounts["high"]))
	}

	// General recommendations based on vulnerability patterns
	if len(vulnerabilities) > 10 {
		recommendations = append(recommendations, 
			"Consider implementing automated dependency scanning in your CI/CD pipeline")
		recommendations = append(recommendations, 
			"Review and update dependencies regularly to maintain security posture")
	}

	if len(vulnerabilities) > 5 {
		recommendations = append(recommendations, 
			"Enable dependency update notifications for timely security patches")
	}

	// Package-specific recommendations
	packageVulnCounts := make(map[string]int)
	for _, vuln := range vulnerabilities {
		if pkg, exists := vuln.Metadata["package_name"]; exists {
			packageVulnCounts[pkg]++
		}
	}

	// Find packages with multiple vulnerabilities
	var problematicPackages []string
	for pkg, count := range packageVulnCounts {
		if count >= 3 {
			problematicPackages = append(problematicPackages, fmt.Sprintf("%s (%d vulnerabilities)", pkg, count))
		}
	}

	if len(problematicPackages) > 0 {
		recommendations = append(recommendations, 
			fmt.Sprintf("Consider replacing packages with multiple vulnerabilities: %v", problematicPackages))
	}

	// Alert-specific recommendations
	if len(alerts) > 0 {
		recommendations = append(recommendations, 
			fmt.Sprintf("Review %d critical vulnerability alerts requiring immediate remediation", len(alerts)))
	}

	// Default recommendations if no vulnerabilities found
	if len(vulnerabilities) == 0 {
		recommendations = append(recommendations, 
			"No known vulnerabilities detected. Continue monitoring for new security advisories.")
		recommendations = append(recommendations, 
			"Consider implementing regular security audits as part of your development workflow.")
	}

	return recommendations
}

// calculateRiskScore calculates an overall security risk score for the project
func (da *DependencyAnalyzer) calculateRiskScore(report *SecurityReport) float64 {
	if report.TotalVulnerabilities == 0 {
		return 0.0
	}

	// Base score calculation using weighted severity scores
	var weightedScore float64
	weights := map[string]float64{
		"critical": 10.0,
		"high":     7.5,
		"medium":   5.0,
		"low":      2.5,
	}

	totalWeight := 0.0
	for severity, count := range report.SeverityDistribution {
		if weight, exists := weights[severity]; exists {
			weightedScore += weight * float64(count)
			totalWeight += float64(count)
		}
	}

	if totalWeight == 0 {
		return 0.0
	}

	// Calculate average weighted score
	averageScore := weightedScore / totalWeight

	// Normalize to 0-100 scale
	riskScore := (averageScore / 10.0) * 100.0

	// Apply multipliers for high vulnerability counts
	if report.TotalVulnerabilities > 20 {
		riskScore *= 1.2 // 20% increase for many vulnerabilities
	} else if report.TotalVulnerabilities > 10 {
		riskScore *= 1.1 // 10% increase for moderate vulnerability count
	}

	// Apply critical vulnerability multiplier
	if report.CriticalCount > 0 {
		criticalMultiplier := 1.0 + (float64(report.CriticalCount) * 0.1)
		riskScore *= criticalMultiplier
	}

	// Cap at 100
	if riskScore > 100.0 {
		riskScore = 100.0
	}

	return riskScore
}

// generateVulnerabilityReport creates a comprehensive vulnerability report
func (da *DependencyAnalyzer) generateVulnerabilityReport(vulnerabilities []Vulnerability, alerts []*VulnerabilityAlert) *SecurityReport {
	report := &SecurityReport{
		VulnerablePackages:   []string{},
		Vulnerabilities:      vulnerabilities,
		SeverityDistribution: make(map[string]int),
		Recommendations:      []string{},
		TotalVulnerabilities: len(vulnerabilities),
	}

	// Count by severity
	for _, vuln := range vulnerabilities {
		report.SeverityDistribution[vuln.Severity]++
		
		switch vuln.Severity {
		case "critical":
			report.CriticalCount++
		case "high":
			report.HighCount++
		case "medium":
			report.MediumCount++
		case "low":
			report.LowCount++
		}
	}

	// Generate recommendations
	report.Recommendations = da.generateSecurityRecommendations(vulnerabilities, alerts)

	// Calculate risk score
	report.RiskScore = da.calculateRiskScore(report)

	return report
}

// sortVulnerabilitiesBySeverity sorts vulnerabilities by severity (critical first)
func sortVulnerabilitiesBySeverity(vulnerabilities []Vulnerability) []Vulnerability {
	severityOrder := map[string]int{
		"critical": 4,
		"high":     3,
		"medium":   2,
		"low":      1,
		"unknown":  0,
	}

	sorted := make([]Vulnerability, len(vulnerabilities))
	copy(sorted, vulnerabilities)

	sort.Slice(sorted, func(i, j int) bool {
		severityI := severityOrder[sorted[i].Severity]
		severityJ := severityOrder[sorted[j].Severity]
		
		if severityI != severityJ {
			return severityI > severityJ // Higher severity first
		}
		
		// If same severity, sort by CVSS score
		return sorted[i].CVSS > sorted[j].CVSS
	})

	return sorted
}

// filterVulnerabilitiesBySeverity filters vulnerabilities by minimum severity level
func filterVulnerabilitiesBySeverity(vulnerabilities []Vulnerability, minSeverity string) []Vulnerability {
	severityOrder := map[string]int{
		"critical": 4,
		"high":     3,
		"medium":   2,
		"low":      1,
		"unknown":  0,
	}

	minLevel := severityOrder[minSeverity]
	var filtered []Vulnerability

	for _, vuln := range vulnerabilities {
		if severityOrder[vuln.Severity] >= minLevel {
			filtered = append(filtered, vuln)
		}
	}

	return filtered
}

// getTopVulnerablePackages returns the packages with the most vulnerabilities
func getTopVulnerablePackages(vulnerabilities []Vulnerability, limit int) []string {
	packageCounts := make(map[string]int)

	for _, vuln := range vulnerabilities {
		if pkg, exists := vuln.Metadata["package_name"]; exists {
			packageCounts[pkg]++
		}
	}

	// Convert to sorted slice
	type packageCount struct {
		name  string
		count int
	}

	var packages []packageCount
	for name, count := range packageCounts {
		packages = append(packages, packageCount{name: name, count: count})
	}

	sort.Slice(packages, func(i, j int) bool {
		return packages[i].count > packages[j].count
	})

	// Return top packages
	var result []string
	for i, pkg := range packages {
		if i >= limit {
			break
		}
		result = append(result, fmt.Sprintf("%s (%d vulnerabilities)", pkg.name, pkg.count))
	}

	return result
}

// createVulnerabilityInsights generates insights about vulnerability patterns
func createVulnerabilityInsights(vulnerabilities []Vulnerability) map[string]interface{} {
	insights := make(map[string]interface{})

	// Age analysis would require parsing dates from vulnerability metadata
	// This could be implemented in future iterations

	// CVSS score distribution
	cvssRanges := map[string]int{
		"0.0-3.9":   0, // Low
		"4.0-6.9":   0, // Medium  
		"7.0-8.9":   0, // High
		"9.0-10.0":  0, // Critical
	}

	for _, vuln := range vulnerabilities {
		switch {
		case vuln.CVSS < 4.0:
			cvssRanges["0.0-3.9"]++
		case vuln.CVSS < 7.0:
			cvssRanges["4.0-6.9"]++
		case vuln.CVSS < 9.0:
			cvssRanges["7.0-8.9"]++
		default:
			cvssRanges["9.0-10.0"]++
		}
	}

	insights["cvss_distribution"] = cvssRanges
	insights["total_vulnerabilities"] = len(vulnerabilities)
	insights["avg_cvss_score"] = calculateAverageCVSS(vulnerabilities)

	return insights
}

// calculateAverageCVSS calculates the average CVSS score
func calculateAverageCVSS(vulnerabilities []Vulnerability) float64 {
	if len(vulnerabilities) == 0 {
		return 0.0
	}

	total := 0.0
	for _, vuln := range vulnerabilities {
		total += vuln.CVSS
	}

	return total / float64(len(vulnerabilities))
}