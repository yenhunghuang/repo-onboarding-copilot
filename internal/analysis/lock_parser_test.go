package analysis

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test data for npm package-lock.json v1
var testNPMLockV1 = `{
  "name": "test-project",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "express": {
      "version": "4.18.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
      "integrity": "sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==",
      "requires": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "cookie": "0.5.0"
      }
    },
    "jest": {
      "version": "28.1.3",
      "resolved": "https://registry.npmjs.org/jest/-/jest-28.1.3.tgz",
      "integrity": "sha512-N4GT5on8UkZgH0O5LUavMRV1EDEhNTL0KEfRmDIeZHSV7p2XgLoY9t9VDUgL6o+yfdgYHVxuz81G8oB9VG5uyA==",
      "dev": true,
      "requires": {
        "@jest/core": "^28.1.3",
        "import-local": "^3.0.2"
      }
    },
    "fsevents": {
      "version": "2.3.2",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
      "optional": true
    }
  }
}`

// Test data for npm package-lock.json v2
var testNPMLockV2 = `{
  "name": "test-project",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "test-project",
      "version": "1.0.0",
      "dependencies": {
        "lodash": "^4.17.21",
        "express": "^4.18.2"
      },
      "devDependencies": {
        "jest": "^28.1.3"
      },
      "optionalDependencies": {
        "fsevents": "^2.3.2"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
    },
    "node_modules/express": {
      "version": "4.18.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
      "integrity": "sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==",
      "dependencies": {
        "accepts": "~1.3.8",
        "cookie": "0.5.0"
      }
    },
    "node_modules/jest": {
      "version": "28.1.3",
      "resolved": "https://registry.npmjs.org/jest/-/jest-28.1.3.tgz",
      "integrity": "sha512-N4GT5on8UkZgH0O5LUavMRV1EDEhNTL0KEfRmDIeZHSV7p2XgLoY9t9VDUgL6o+yfdgYHVxuz81G8oB9VG5uyA==",
      "dev": true,
      "dependencies": {
        "@jest/core": "^28.1.3"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.2",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
      "optional": true
    }
  }
}`

// Test data for Yarn lock file
var testYarnLock = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

"@babel/core@^7.0.0", "@babel/core@^7.1.0":
  version "7.20.12"
  resolved "https://registry.yarnpkg.com/@babel/core/-/core-7.20.12.tgz#7930db57443c6714ad216953d772d4af662b0c8c"
  integrity sha512-XsMfHovsUYHFMdrIHkZphTN/2Hzzi78R08NuHfDBehym2VsPDL6Zn/JAD/JQdnRvbSsbQc4mVaU1m6JgtTEElg==
  dependencies:
    "@ampproject/remapping" "^2.1.0"
    "@babel/code-frame" "^7.18.6"

express@^4.18.0:
  version "4.18.2"
  resolved "https://registry.yarnpkg.com/express/-/express-4.18.2.tgz#3fabe32695fc6a8a14eb7dbb6a849c0c0c4b6ba9"
  integrity sha512-5/PsL6iGPdfQ/lKM1UuielYgv3BUoJfz1aUwU9vHZ+J7gyvwdQXFEBIEIaxeGf0GIcreATNyBExtalisDbuMqQ==
  dependencies:
    accepts "~1.3.8"
    array-flatten "1.1.1"

lodash@~4.17.21:
  version "4.17.21"
  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.21.tgz#679591c564c3bffaae8454cf0b3df370c3d6911c"
  integrity sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==

jest@^28.1.0:
  version "28.1.3"
  resolved "https://registry.yarnpkg.com/jest/-/jest-28.1.3.tgz#e9b4f02b52e53d13c4c4aa1f0cbb2c3f31e2c74b"
  integrity sha512-N4GT5on8UkZgH0O5LUavMRV1EDEhNTL0KEfRmDIeZHSV7p2XgLoY9t9VDUgL6o+yfdgYHVxuz81G8oB9VG5uyA==
  dependencies:
    "@jest/core" "^28.1.3"
    import-local "^3.0.2"
`

func TestParseNPMLockFileV1(t *testing.T) {
	// Create temporary file
	tempDir := t.TempDir()
	lockPath := filepath.Join(tempDir, "package-lock.json")

	err := os.WriteFile(lockPath, []byte(testNPMLockV1), 0644)
	require.NoError(t, err)

	// Create analyzer
	analyzer, err := NewDependencyAnalyzer(DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	})
	require.NoError(t, err)

	// Parse lock file
	lockFile, err := analyzer.parseNPMLockFile(lockPath)
	require.NoError(t, err)
	require.NotNil(t, lockFile)

	// Verify basic properties
	assert.Equal(t, "npm-lock", lockFile.Type)
	assert.Equal(t, "1", lockFile.Version)

	// Verify dependencies are parsed
	assert.Len(t, lockFile.Dependencies, 4)

	// Test lodash entry
	lodash := lockFile.Dependencies["lodash"]
	assert.Equal(t, "4.17.21", lodash.Version)
	assert.Equal(t, "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz", lodash.Resolved)
	assert.Equal(t, "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==", lodash.Integrity)
	assert.False(t, lodash.DevDep)
	assert.False(t, lodash.Optional)

	// Test express with dependencies
	express := lockFile.Dependencies["express"]
	assert.Equal(t, "4.18.2", express.Version)
	assert.Len(t, express.Dependencies, 3)
	assert.Contains(t, express.Dependencies, "accepts")
	assert.Equal(t, "~1.3.8", express.Dependencies["accepts"])

	// Test jest (dev dependency)
	jest := lockFile.Dependencies["jest"]
	assert.Equal(t, "28.1.3", jest.Version)
	assert.True(t, jest.DevDep)
	assert.Len(t, jest.Dependencies, 2)

	// Test fsevents (optional dependency)
	fsevents := lockFile.Dependencies["fsevents"]
	assert.Equal(t, "2.3.2", fsevents.Version)
	assert.True(t, fsevents.Optional)

	// Verify metadata is stored
	assert.Contains(t, lockFile.Metadata, "name")
	assert.Contains(t, lockFile.Metadata, "version")
	assert.Contains(t, lockFile.Metadata, "requires")
}

func TestParseNPMLockFileV2(t *testing.T) {
	tempDir := t.TempDir()
	lockPath := filepath.Join(tempDir, "package-lock.json")

	err := os.WriteFile(lockPath, []byte(testNPMLockV2), 0644)
	require.NoError(t, err)

	analyzer, err := NewDependencyAnalyzer(DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	})
	require.NoError(t, err)

	lockFile, err := analyzer.parseNPMLockFile(lockPath)
	require.NoError(t, err)
	require.NotNil(t, lockFile)

	// Verify basic properties
	assert.Equal(t, "npm-lock", lockFile.Type)
	assert.Equal(t, "2", lockFile.Version)

	// Verify dependencies are parsed
	assert.Len(t, lockFile.Dependencies, 4)

	// Test package extraction from paths
	assert.Contains(t, lockFile.Dependencies, "lodash")
	assert.Contains(t, lockFile.Dependencies, "express")
	assert.Contains(t, lockFile.Dependencies, "jest")
	assert.Contains(t, lockFile.Dependencies, "fsevents")

	// Test dev dependency flag
	jest := lockFile.Dependencies["jest"]
	assert.True(t, jest.DevDep)

	// Test optional dependency flag
	fsevents := lockFile.Dependencies["fsevents"]
	assert.True(t, fsevents.Optional)
}

func TestExtractPackageNameFromPath(t *testing.T) {
	analyzer := &DependencyAnalyzer{}

	tests := []struct {
		name     string
		path     string
		expected string
	}{
		{
			name:     "root package",
			path:     "",
			expected: "",
		},
		{
			name:     "current directory",
			path:     ".",
			expected: "",
		},
		{
			name:     "simple package",
			path:     "node_modules/lodash",
			expected: "lodash",
		},
		{
			name:     "scoped package",
			path:     "node_modules/@babel/core",
			expected: "@babel/core",
		},
		{
			name:     "nested package",
			path:     "node_modules/express/node_modules/accepts",
			expected: "express",
		},
		{
			name:     "scoped nested",
			path:     "node_modules/@types/node/node_modules/something",
			expected: "@types/node",
		},
		{
			name:     "without node_modules prefix",
			path:     "lodash",
			expected: "lodash",
		},
		{
			name:     "scoped without prefix",
			path:     "@babel/core",
			expected: "@babel/core",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := analyzer.extractPackageNameFromPath(tt.path)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestParseYarnLockFile(t *testing.T) {
	tempDir := t.TempDir()
	lockPath := filepath.Join(tempDir, "yarn.lock")

	err := os.WriteFile(lockPath, []byte(testYarnLock), 0644)
	require.NoError(t, err)

	analyzer, err := NewDependencyAnalyzer(DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	})
	require.NoError(t, err)

	lockFile, err := analyzer.parseYarnLockFile(lockPath)
	require.NoError(t, err)
	require.NotNil(t, lockFile)

	// Verify basic properties
	assert.Equal(t, "yarn-lock", lockFile.Type)
	assert.Equal(t, "1", lockFile.Version)

	// Verify dependencies are parsed
	assert.Len(t, lockFile.Dependencies, 4)

	// Test @babel/core entry (with multiple version ranges)
	babelCore := lockFile.Dependencies["@babel/core"]
	assert.Equal(t, "7.20.12", babelCore.Version)
	assert.Equal(t, "https://registry.yarnpkg.com/@babel/core/-/core-7.20.12.tgz#7930db57443c6714ad216953d772d4af662b0c8c", babelCore.Resolved)
	assert.Equal(t, "sha512-XsMfHovsUYHFMdrIHkZphTN/2Hzzi78R08NuHfDBehym2VsPDL6Zn/JAD/JQdnRvbSsbQc4mVaU1m6JgtTEElg==", babelCore.Integrity)
	assert.Len(t, babelCore.Dependencies, 2)
	assert.Contains(t, babelCore.Dependencies, "@ampproject/remapping")

	// Test express entry
	express := lockFile.Dependencies["express"]
	assert.Equal(t, "4.18.2", express.Version)
	assert.Len(t, express.Dependencies, 2)
	assert.Contains(t, express.Dependencies, "accepts")
	assert.Equal(t, "~1.3.8", express.Dependencies["accepts"])

	// Test lodash entry
	lodash := lockFile.Dependencies["lodash"]
	assert.Equal(t, "4.17.21", lodash.Version)

	// Test jest entry
	jest := lockFile.Dependencies["jest"]
	assert.Equal(t, "28.1.3", jest.Version)
	assert.Len(t, jest.Dependencies, 2)
}

func TestParseYarnPackageNames(t *testing.T) {
	analyzer := &DependencyAnalyzer{}

	tests := []struct {
		name     string
		header   string
		expected []string
	}{
		{
			name:     "single package",
			header:   `"lodash@^4.17.21":`,
			expected: []string{"lodash"},
		},
		{
			name:     "multiple versions of same package",
			header:   `"@babel/core@^7.0.0", "@babel/core@^7.1.0":`,
			expected: []string{"@babel/core"},
		},
		{
			name:     "scoped package",
			header:   `"@types/node@^18.0.0":`,
			expected: []string{"@types/node"},
		},
		{
			name:     "multiple different packages",
			header:   `"express@^4.18.0", "lodash@^4.17.21":`,
			expected: []string{"express", "lodash"},
		},
		{
			name:     "without quotes",
			header:   `lodash@^4.17.21:`,
			expected: []string{"lodash"},
		},
		{
			name:     "complex version ranges",
			header:   `"package@>=1.0.0 <2.0.0":`,
			expected: []string{"package"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := analyzer.parseYarnPackageNames(tt.header)
			assert.ElementsMatch(t, tt.expected, result)
		})
	}
}

func TestParseInvalidLockFiles(t *testing.T) {
	tempDir := t.TempDir()
	analyzer, err := NewDependencyAnalyzer(DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	})
	require.NoError(t, err)

	t.Run("invalid npm lock JSON", func(t *testing.T) {
		lockPath := filepath.Join(tempDir, "invalid-npm.json")
		err := os.WriteFile(lockPath, []byte(`{invalid json}`), 0644)
		require.NoError(t, err)

		_, err = analyzer.parseNPMLockFile(lockPath)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "invalid JSON")
	})

	t.Run("missing npm lock file", func(t *testing.T) {
		_, err = analyzer.parseNPMLockFile("/non/existent/file.json")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to read")
	})

	t.Run("missing yarn lock file", func(t *testing.T) {
		_, err = analyzer.parseYarnLockFile("/non/existent/yarn.lock")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to open")
	})
}

func TestEmptyLockFiles(t *testing.T) {
	tempDir := t.TempDir()
	analyzer, err := NewDependencyAnalyzer(DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	})
	require.NoError(t, err)

	t.Run("empty npm lock file", func(t *testing.T) {
		lockPath := filepath.Join(tempDir, "empty-npm.json")
		err := os.WriteFile(lockPath, []byte(`{"lockfileVersion": 1}`), 0644)
		require.NoError(t, err)

		lockFile, err := analyzer.parseNPMLockFile(lockPath)
		require.NoError(t, err)
		assert.Equal(t, "npm-lock", lockFile.Type)
		assert.Equal(t, "1", lockFile.Version)
		assert.Empty(t, lockFile.Dependencies)
	})

	t.Run("empty yarn lock file", func(t *testing.T) {
		lockPath := filepath.Join(tempDir, "empty-yarn.lock")
		err := os.WriteFile(lockPath, []byte("# yarn lockfile v1\n"), 0644)
		require.NoError(t, err)

		lockFile, err := analyzer.parseYarnLockFile(lockPath)
		require.NoError(t, err)
		assert.Equal(t, "yarn-lock", lockFile.Type)
		assert.Equal(t, "1", lockFile.Version)
		assert.Empty(t, lockFile.Dependencies)
	})
}

// Benchmark tests
func BenchmarkParseNPMLockV1(b *testing.B) {
	tempDir := b.TempDir()
	lockPath := filepath.Join(tempDir, "package-lock.json")

	err := os.WriteFile(lockPath, []byte(testNPMLockV1), 0644)
	require.NoError(b, err)

	analyzer, err := NewDependencyAnalyzer(DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	})
	require.NoError(b, err)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := analyzer.parseNPMLockFile(lockPath)
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkParseYarnLock(b *testing.B) {
	tempDir := b.TempDir()
	lockPath := filepath.Join(tempDir, "yarn.lock")

	err := os.WriteFile(lockPath, []byte(testYarnLock), 0644)
	require.NoError(b, err)

	analyzer, err := NewDependencyAnalyzer(DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	})
	require.NoError(b, err)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := analyzer.parseYarnLockFile(lockPath)
		if err != nil {
			b.Fatal(err)
		}
	}
}