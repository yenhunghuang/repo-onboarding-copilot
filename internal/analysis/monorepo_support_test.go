package analysis

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestDetectMonorepoStructure(t *testing.T) {
	tests := []struct {
		name           string
		setupFunc      func(t *testing.T, rootDir string)
		expectedType   string
		expectedPkgs   int
		shouldError    bool
		shouldBeNil    bool
	}{
		{
			name: "npm_workspaces_array_format",
			setupFunc: func(t *testing.T, rootDir string) {
				// Create root package.json with workspaces array
				packageJSON := map[string]interface{}{
					"name":       "test-monorepo",
					"version":    "1.0.0",
					"private":    true,
					"workspaces": []string{"packages/*", "apps/*"},
				}
				writeJSON(t, filepath.Join(rootDir, "package.json"), packageJSON)

				// Create workspace packages
				createTestPackage(t, filepath.Join(rootDir, "packages", "package-a"), "package-a", "1.0.0")
				createTestPackage(t, filepath.Join(rootDir, "packages", "package-b"), "package-b", "1.0.0")
				createTestPackage(t, filepath.Join(rootDir, "apps", "app-web"), "app-web", "1.0.0")
			},
			expectedType: "npm-workspaces",
			expectedPkgs: 3,
		},
		{
			name: "npm_workspaces_object_format",
			setupFunc: func(t *testing.T, rootDir string) {
				// Create root package.json with workspaces object
				packageJSON := map[string]interface{}{
					"name":    "test-monorepo",
					"version": "1.0.0",
					"private": true,
					"workspaces": map[string]interface{}{
						"packages": []string{"libs/*"},
						"nohoist":  []string{"**/react", "**/react-dom"},
					},
				}
				writeJSON(t, filepath.Join(rootDir, "package.json"), packageJSON)

				// Create workspace packages
				createTestPackage(t, filepath.Join(rootDir, "libs", "lib-utils"), "lib-utils", "2.0.0")
				createTestPackage(t, filepath.Join(rootDir, "libs", "lib-shared"), "lib-shared", "1.5.0")
			},
			expectedType: "npm-workspaces",
			expectedPkgs: 2,
		},
		{
			name: "yarn_workspaces",
			setupFunc: func(t *testing.T, rootDir string) {
				// Create root package.json with workspaces
				packageJSON := map[string]interface{}{
					"name":       "yarn-monorepo",
					"version":    "1.0.0",
					"private":    true,
					"workspaces": []string{"packages/*"},
				}
				writeJSON(t, filepath.Join(rootDir, "package.json"), packageJSON)

				// Create yarn.lock to indicate Yarn usage
				yarnLock := `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

package-a@1.0.0:
  version "1.0.0"
  resolved "https://registry.yarnpkg.com/package-a/-/package-a-1.0.0.tgz"
`
				err := os.WriteFile(filepath.Join(rootDir, "yarn.lock"), []byte(yarnLock), 0644)
				require.NoError(t, err)

				// Create workspace package
				createTestPackage(t, filepath.Join(rootDir, "packages", "package-a"), "package-a", "1.0.0")
			},
			expectedType: "yarn-workspaces",
			expectedPkgs: 1,
		},
		{
			name: "lerna_monorepo",
			setupFunc: func(t *testing.T, rootDir string) {
				// Create lerna.json
				lernaConfig := map[string]interface{}{
					"version":  "0.0.0",
					"packages": []string{"packages/*"},
					"command": map[string]interface{}{
						"publish": map[string]interface{}{
							"conventionalCommits": true,
						},
					},
				}
				writeJSON(t, filepath.Join(rootDir, "lerna.json"), lernaConfig)

				// Create package.json without workspaces
				packageJSON := map[string]interface{}{
					"name":    "lerna-monorepo",
					"version": "1.0.0",
					"private": true,
				}
				writeJSON(t, filepath.Join(rootDir, "package.json"), packageJSON)

				// Create workspace packages
				createTestPackage(t, filepath.Join(rootDir, "packages", "pkg-core"), "pkg-core", "1.2.0")
				createTestPackage(t, filepath.Join(rootDir, "packages", "pkg-utils"), "pkg-utils", "1.1.0")
			},
			expectedType: "lerna",
			expectedPkgs: 2,
		},
		{
			name: "lerna_with_workspaces",
			setupFunc: func(t *testing.T, rootDir string) {
				// Create lerna.json with useWorkspaces
				lernaConfig := map[string]interface{}{
					"version":       "independent",
					"packages":      []string{"packages/*"},
					"useWorkspaces": true,
					"npmClient":     "yarn",
				}
				writeJSON(t, filepath.Join(rootDir, "lerna.json"), lernaConfig)

				// Create package.json with workspaces
				packageJSON := map[string]interface{}{
					"name":       "lerna-workspace-monorepo",
					"version":    "1.0.0",
					"private":    true,
					"workspaces": []string{"packages/*"},
				}
				writeJSON(t, filepath.Join(rootDir, "package.json"), packageJSON)

				// Create workspace package
				createTestPackage(t, filepath.Join(rootDir, "packages", "shared"), "shared", "0.1.0")
			},
			expectedType: "lerna-workspaces",
			expectedPkgs: 1,
		},
		{
			name: "not_a_monorepo",
			setupFunc: func(t *testing.T, rootDir string) {
				// Create regular package.json without workspaces
				packageJSON := map[string]interface{}{
					"name":    "regular-package",
					"version": "1.0.0",
				}
				writeJSON(t, filepath.Join(rootDir, "package.json"), packageJSON)
			},
			shouldBeNil: true,
		},
		{
			name: "cross_package_dependencies",
			setupFunc: func(t *testing.T, rootDir string) {
				// Create root package.json with workspaces
				packageJSON := map[string]interface{}{
					"name":       "cross-deps-monorepo",
					"version":    "1.0.0",
					"private":    true,
					"workspaces": []string{"packages/*"},
				}
				writeJSON(t, filepath.Join(rootDir, "package.json"), packageJSON)

				// Create package A that depends on package B
				createTestPackageWithDeps(t, filepath.Join(rootDir, "packages", "package-a"), "package-a", "1.0.0", 
					map[string]string{
						"package-b": "^1.0.0",
						"lodash":    "^4.17.21",
					})

				// Create package B
				createTestPackageWithDeps(t, filepath.Join(rootDir, "packages", "package-b"), "package-b", "1.0.0",
					map[string]string{
						"express": "^4.18.0",
					})
			},
			expectedType: "npm-workspaces",
			expectedPkgs: 2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temporary directory
			tempDir, err := os.MkdirTemp("", "monorepo-test-*")
			require.NoError(t, err)
			defer os.RemoveAll(tempDir)

			// Set up test scenario
			tt.setupFunc(t, tempDir)

			// Create analyzer
			config := DependencyAnalyzerConfig{
				ProjectRoot: tempDir,
			}
			analyzer, err := NewDependencyAnalyzer(config)
			require.NoError(t, err)

			// Test monorepo detection
			structure, err := analyzer.detectMonorepoStructure()

			if tt.shouldError {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)

			if tt.shouldBeNil {
				assert.Nil(t, structure)
				return
			}

			require.NotNil(t, structure)
			assert.Equal(t, tt.expectedType, structure.Type)
			assert.Len(t, structure.Packages, tt.expectedPkgs)
			assert.Equal(t, tempDir, structure.RootPath)

			// Verify cross-package dependencies for the relevant test
			if tt.name == "cross_package_dependencies" {
				require.Contains(t, structure.CrossPackageDeps, "package-a")
				assert.Contains(t, structure.CrossPackageDeps["package-a"], "package-b")
				
				pkgA := structure.Packages["package-a"]
				require.NotNil(t, pkgA)
				assert.Contains(t, pkgA.WorkspaceDeps, "package-b")
				assert.Contains(t, pkgA.ExternalDeps, "lodash")
				
				pkgB := structure.Packages["package-b"]
				require.NotNil(t, pkgB)
				assert.Contains(t, pkgB.ExternalDeps, "express")
				assert.Empty(t, pkgB.WorkspaceDeps)
			}
		})
	}
}

func TestParseWorkspaceConfig(t *testing.T) {
	tests := []struct {
		name         string
		workspaces   interface{}
		expectedPkgs []string
		expectedNoHoist []string
		shouldError  bool
	}{
		{
			name:         "array_format",
			workspaces:   []interface{}{"packages/*", "apps/*"},
			expectedPkgs: []string{"packages/*", "apps/*"},
		},
		{
			name: "object_format",
			workspaces: map[string]interface{}{
				"packages": []interface{}{"libs/*", "tools/*"},
				"nohoist":  []interface{}{"**/react", "**/webpack"},
			},
			expectedPkgs:    []string{"libs/*", "tools/*"},
			expectedNoHoist: []string{"**/react", "**/webpack"},
		},
		{
			name: "object_format_with_metadata",
			workspaces: map[string]interface{}{
				"packages":       []interface{}{"modules/*"},
				"nohoist":        []interface{}{"**/typescript"},
				"custom_setting": "custom_value",
			},
			expectedPkgs:    []string{"modules/*"},
			expectedNoHoist: []string{"**/typescript"},
		},
		{
			name:        "invalid_format",
			workspaces:  "invalid",
			shouldError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			analyzer := &DependencyAnalyzer{}
			manifest := &PackageManifest{
				Workspaces: tt.workspaces,
			}

			config, err := analyzer.parseWorkspaceConfig(manifest)

			if tt.shouldError {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.expectedPkgs, config.Packages)
			assert.Equal(t, tt.expectedNoHoist, config.NohoisT)

			if tt.name == "object_format_with_metadata" {
				assert.Contains(t, config.Metadata, "custom_setting")
				assert.Equal(t, "custom_value", config.Metadata["custom_setting"])
			}
		})
	}
}

func TestIntegrateMonorepoWithDependencyTree(t *testing.T) {
	tempDir, err := os.MkdirTemp("", "monorepo-integration-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	// Set up test monorepo
	packageJSON := map[string]interface{}{
		"name":       "integration-test",
		"version":    "1.0.0",
		"private":    true,
		"workspaces": []string{"packages/*"},
	}
	writeJSON(t, filepath.Join(tempDir, "package.json"), packageJSON)

	createTestPackage(t, filepath.Join(tempDir, "packages", "pkg-a"), "pkg-a", "1.0.0")
	createTestPackage(t, filepath.Join(tempDir, "packages", "pkg-b"), "pkg-b", "2.0.0")

	// Create analyzer and detect monorepo
	config := DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	}
	analyzer, err := NewDependencyAnalyzer(config)
	require.NoError(t, err)

	structure, err := analyzer.detectMonorepoStructure()
	require.NoError(t, err)
	require.NotNil(t, structure)

	// Create a basic dependency tree
	tree := &DependencyTree{
		RootPackage:     structure.RootManifest,
		DirectDeps:      make(map[string]*DependencyNode),
		AllDependencies: make(map[string]*DependencyNode),
		Statistics:      DependencyStats{TypeDistribution: make(map[string]int)},
	}

	// Test integration
	ctx := context.Background()
	err = analyzer.integrateMonorepoWithDependencyTree(ctx, tree, structure)
	require.NoError(t, err)

	// Verify integration
	assert.Contains(t, tree.AllDependencies, "pkg-a")
	assert.Contains(t, tree.AllDependencies, "pkg-b")
	assert.Contains(t, tree.Statistics.TypeDistribution, "workspace")
	assert.Equal(t, 2, tree.Statistics.TypeDistribution["workspace"])

	// Verify workspace node properties
	pkgANode := tree.AllDependencies["pkg-a"]
	assert.Equal(t, "workspace", pkgANode.Type)
	assert.Equal(t, "packages/pkg-a", pkgANode.Path)
	assert.False(t, pkgANode.IsTransitive)
}

// Helper functions for testing

func writeJSON(t *testing.T, filePath string, data interface{}) {
	// Ensure directory exists
	dir := filepath.Dir(filePath)
	err := os.MkdirAll(dir, 0755)
	require.NoError(t, err)

	// Write JSON file
	content, err := json.MarshalIndent(data, "", "  ")
	require.NoError(t, err)

	err = os.WriteFile(filePath, content, 0644)
	require.NoError(t, err)
}

func createTestPackage(t *testing.T, packageDir, name, version string) {
	packageJSON := map[string]interface{}{
		"name":    name,
		"version": version,
		"main":    "index.js",
	}
	writeJSON(t, filepath.Join(packageDir, "package.json"), packageJSON)
}

func createTestPackageWithDeps(t *testing.T, packageDir, name, version string, deps map[string]string) {
	packageJSON := map[string]interface{}{
		"name":         name,
		"version":      version,
		"main":         "index.js",
		"dependencies": deps,
	}
	writeJSON(t, filepath.Join(packageDir, "package.json"), packageJSON)
}

func TestExtendAnalysisForMonorepo(t *testing.T) {
	tempDir, err := os.MkdirTemp("", "extend-analysis-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tempDir)

	// Set up test monorepo with cross-dependencies
	packageJSON := map[string]interface{}{
		"name":       "extended-analysis-test",
		"version":    "1.0.0",
		"private":    true,
		"workspaces": []string{"packages/*"},
		"dependencies": map[string]string{
			"lodash": "^4.17.21",
		},
	}
	writeJSON(t, filepath.Join(tempDir, "package.json"), packageJSON)

	// Create packages with cross-dependencies
	createTestPackageWithDeps(t, filepath.Join(tempDir, "packages", "core"), "core", "1.0.0", 
		map[string]string{
			"utils":  "^1.0.0",
			"moment": "^2.29.0",
		})
	
	createTestPackageWithDeps(t, filepath.Join(tempDir, "packages", "utils"), "utils", "1.0.0",
		map[string]string{
			"ramda": "^0.28.0",
		})

	// Create analyzer
	config := DependencyAnalyzerConfig{
		ProjectRoot: tempDir,
	}
	analyzer, err := NewDependencyAnalyzer(config)
	require.NoError(t, err)

	// Create initial dependency tree
	manifest, err := analyzer.parsePackageJSON(filepath.Join(tempDir, "package.json"))
	require.NoError(t, err)

	tree := &DependencyTree{
		RootPackage:     manifest,
		DirectDeps:      make(map[string]*DependencyNode),
		AllDependencies: make(map[string]*DependencyNode),
		Statistics:      DependencyStats{TypeDistribution: make(map[string]int)},
	}

	// Test extending analysis for monorepo
	ctx := context.Background()
	err = analyzer.extendAnalysisForMonorepo(ctx, tree)
	require.NoError(t, err)

	// Verify monorepo metadata was added
	assert.True(t, tree.RootPackage.Metadata["is_monorepo"].(bool))
	assert.Equal(t, "npm-workspaces", tree.RootPackage.Metadata["monorepo_type"])
	assert.Contains(t, tree.RootPackage.Metadata, "monorepo_structure")

	// Verify workspace packages were added
	assert.Contains(t, tree.AllDependencies, "core")
	assert.Contains(t, tree.AllDependencies, "utils")

	// Verify cross-package dependency was detected
	coreNode := tree.AllDependencies["core"]
	assert.Contains(t, coreNode.Children, "utils")
}