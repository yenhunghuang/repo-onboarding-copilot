// Package analysis provides vulnerability scanning for npm packages
package analysis

import (
	"context"
	"fmt"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// VulnerabilityDatabase manages vulnerability data from multiple sources
type VulnerabilityDatabase struct {
	client         *http.Client
	sources        []VulnerabilitySource
	cache          VulnerabilityCache
	updateInterval time.Duration
	lastUpdate     time.Time
}

// VulnerabilitySource represents a vulnerability data source
type VulnerabilitySource interface {
	GetName() string
	QueryVulnerabilities(ctx context.Context, packageName, version string) ([]Vulnerability, error)
	GetLastUpdate() time.Time
	UpdateCache(ctx context.Context) error
}

// VulnerabilityCache provides caching for vulnerability data
type VulnerabilityCache interface {
	Get(key string) ([]Vulnerability, bool)
	Set(key string, vulns []Vulnerability, ttl time.Duration)
	Clear()
	Size() int
}

// NPMAdvisorySource integrates with npm audit database
type NPMAdvisorySource struct {
	baseURL    string
	client     *http.Client
	lastUpdate time.Time
}

// GitHubAdvisorySource integrates with GitHub Security Advisory Database
type GitHubAdvisorySource struct {
	baseURL    string
	client     *http.Client
	apiToken   string
	lastUpdate time.Time
}

// OSVSource integrates with Open Source Vulnerabilities Database
type OSVSource struct {
	baseURL    string
	client     *http.Client
	lastUpdate time.Time
}

// VulnerabilityMatch represents a vulnerability matched to a specific package version
type VulnerabilityMatch struct {
	Vulnerability    Vulnerability `json:"vulnerability"`
	PackageName     string        `json:"package_name"`
	PackageVersion  string        `json:"package_version"`
	MatchType       string        `json:"match_type"`       // exact, range, wildcard
	Confidence      float64       `json:"confidence"`       // 0-1 match confidence score
	Source          string        `json:"source"`           // vulnerability database source
	MatchedRange    string        `json:"matched_range"`    // the specific range that matched
}

// SeverityScore represents CVSS scoring information
type SeverityScore struct {
	Score           float64           `json:"score"`            // CVSS score 0-10
	Vector          string            `json:"vector"`           // CVSS vector string
	Version         string            `json:"version"`          // CVSS version (2.0, 3.0, 3.1)
	BaseScore       float64           `json:"base_score"`       // CVSS base score
	TemporalScore   float64           `json:"temporal_score"`   // CVSS temporal score
	EnvironmentalScore float64        `json:"environmental_score"` // CVSS environmental score
	Metrics         map[string]string `json:"metrics"`          // individual CVSS metrics
}

// VulnerabilityAlert represents a critical vulnerability alert
type VulnerabilityAlert struct {
	ID                string            `json:"id"`
	PackageName       string            `json:"package_name"`
	PackageVersion    string            `json:"package_version"`
	Vulnerability     Vulnerability     `json:"vulnerability"`
	Severity          string            `json:"severity"`
	Priority          string            `json:"priority"`       // immediate, urgent, high, medium, low
	Timestamp         time.Time         `json:"timestamp"`
	RemediationSteps  []string          `json:"remediation_steps"`
	EstimatedEffort   string            `json:"estimated_effort"` // low, medium, high
	BusinessImpact    string            `json:"business_impact"`  // critical, high, medium, low
	Metadata          map[string]string `json:"metadata"`
}

// MemoryVulnerabilityCache provides in-memory caching for vulnerability data
type MemoryVulnerabilityCache struct {
	cache map[string]vulnCacheEntry
}

type vulnCacheEntry struct {
	vulnerabilities []Vulnerability
	expiry          time.Time
}

// NewVulnerabilityDatabase creates a new vulnerability database with multiple sources
func NewVulnerabilityDatabase() (*VulnerabilityDatabase, error) {
	client := &http.Client{
		Timeout: 30 * time.Second,
	}

	// Initialize vulnerability sources
	sources := []VulnerabilitySource{
		&NPMAdvisorySource{
			baseURL: "https://registry.npmjs.org/-/npm/v1/security/audits",
			client:  client,
		},
		&GitHubAdvisorySource{
			baseURL: "https://api.github.com/graphql",
			client:  client,
		},
		&OSVSource{
			baseURL: "https://api.osv.dev/v1",
			client:  client,
		},
	}

	cache := &MemoryVulnerabilityCache{
		cache: make(map[string]vulnCacheEntry),
	}

	db := &VulnerabilityDatabase{
		client:         client,
		sources:        sources,
		cache:          cache,
		updateInterval: 24 * time.Hour, // Update daily
		lastUpdate:     time.Time{},
	}

	return db, nil
}

// CheckVulnerabilities checks for vulnerabilities in the given packages
func (vdb *VulnerabilityDatabase) CheckVulnerabilities(ctx context.Context, packages []string) ([]Vulnerability, error) {
	var allVulns []Vulnerability
	processed := make(map[string]bool)

	for _, pkg := range packages {
		if processed[pkg] {
			continue
		}
		processed[pkg] = true

		// Parse package name and version
		name, version, err := parsePackageSpec(pkg)
		if err != nil {
			continue // Skip invalid package specifications
		}

		// Check cache first
		cacheKey := fmt.Sprintf("%s@%s", name, version)
		if vulns, found := vdb.cache.Get(cacheKey); found {
			allVulns = append(allVulns, vulns...)
			continue
		}

		// Query all sources for this package
		var packageVulns []Vulnerability
		for _, source := range vdb.sources {
			sourceVulns, err := source.QueryVulnerabilities(ctx, name, version)
			if err != nil {
				// Log error but continue with other sources
				continue
			}
			packageVulns = append(packageVulns, sourceVulns...)
		}

		// Remove duplicates and cache results
		packageVulns = deduplicateVulnerabilities(packageVulns)
		vdb.cache.Set(cacheKey, packageVulns, 24*time.Hour)
		allVulns = append(allVulns, packageVulns...)
	}

	return allVulns, nil
}

// MatchVulnerabilities matches vulnerabilities to specific package versions using semantic versioning
func (vdb *VulnerabilityDatabase) MatchVulnerabilities(ctx context.Context, packageName, packageVersion string) ([]VulnerabilityMatch, error) {
	// Get all known vulnerabilities for this package
	vulns, err := vdb.CheckVulnerabilities(ctx, []string{packageName + "@" + packageVersion})
	if err != nil {
		return nil, fmt.Errorf("failed to check vulnerabilities: %w", err)
	}

	var matches []VulnerabilityMatch

	for _, vuln := range vulns {
		// Check if this vulnerability affects the specific version
		for _, affectedRange := range vuln.AffectedIn {
			if matchResult := matchVersionToRange(packageVersion, affectedRange); matchResult != nil {
				match := VulnerabilityMatch{
					Vulnerability:  vuln,
					PackageName:    packageName,
					PackageVersion: packageVersion,
					MatchType:      matchResult.MatchType,
					Confidence:     matchResult.Confidence,
					Source:         vuln.References[0], // Use first reference as source indicator
					MatchedRange:   affectedRange,
				}
				matches = append(matches, match)
			}
		}
	}

	return matches, nil
}

// CalculateSeverityScore calculates comprehensive severity scoring
func (vdb *VulnerabilityDatabase) CalculateSeverityScore(vulnerability Vulnerability) (*SeverityScore, error) {
	score := &SeverityScore{
		Score:   vulnerability.CVSS,
		Version: "3.1", // Default to CVSS 3.1
		Metrics: make(map[string]string),
	}

	// Parse CVSS vector if available
	for _, ref := range vulnerability.References {
		if strings.Contains(ref, "CVSS:") {
			vector := extractCVSSVector(ref)
			if vector != "" {
				score.Vector = vector
				parsedMetrics := parseCVSSVector(vector)
				for k, v := range parsedMetrics {
					score.Metrics[k] = v
				}
				break
			}
		}
	}

	// Set base score from CVSS
	score.BaseScore = vulnerability.CVSS

	// Calculate severity category
	severity := calculateSeverityCategory(vulnerability.CVSS)
	if vulnerability.Severity == "" {
		vulnerability.Severity = severity
	}

	return score, nil
}

// GenerateAlert creates a vulnerability alert for critical issues
func (vdb *VulnerabilityDatabase) GenerateAlert(match VulnerabilityMatch) *VulnerabilityAlert {
	alert := &VulnerabilityAlert{
		ID:             fmt.Sprintf("ALERT-%s-%s", match.PackageName, match.Vulnerability.ID),
		PackageName:    match.PackageName,
		PackageVersion: match.PackageVersion,
		Vulnerability:  match.Vulnerability,
		Severity:       match.Vulnerability.Severity,
		Timestamp:      time.Now(),
		Metadata:       make(map[string]string),
	}

	// Determine alert priority based on CVSS score and context
	alert.Priority = calculateAlertPriority(match.Vulnerability.CVSS, match.Confidence)

	// Generate remediation steps
	alert.RemediationSteps = generateRemediationSteps(match)

	// Estimate effort and business impact
	alert.EstimatedEffort = estimateEffort(match)
	alert.BusinessImpact = assessBusinessImpact(match)

	return alert
}

// Close closes the vulnerability database and releases resources
func (vdb *VulnerabilityDatabase) Close() error {
	vdb.cache.Clear()
	return nil
}

// Helper functions

func parsePackageSpec(spec string) (name, version string, err error) {
	parts := strings.Split(spec, "@")
	if len(parts) < 2 {
		return "", "", fmt.Errorf("invalid package specification: %s", spec)
	}
	if len(parts) == 2 {
		return parts[0], parts[1], nil
	}
	// Handle scoped packages like @types/node@1.0.0
	if strings.HasPrefix(spec, "@") {
		name = strings.Join(parts[0:2], "@")
		version = strings.Join(parts[2:], "@")
		return name, version, nil
	}
	return parts[0], strings.Join(parts[1:], "@"), nil
}

type versionMatchResult struct {
	MatchType  string
	Confidence float64
}

func matchVersionToRange(version, versionRange string) *versionMatchResult {
	// Exact version match
	if version == versionRange {
		return &versionMatchResult{
			MatchType:  "exact",
			Confidence: 1.0,
		}
	}

	// Semantic version range matching
	if matched, confidence := matchSemanticVersionRange(version, versionRange); matched {
		return &versionMatchResult{
			MatchType:  "range",
			Confidence: confidence,
		}
	}

	// Wildcard matching
	if matched, confidence := matchWildcardRange(version, versionRange); matched {
		return &versionMatchResult{
			MatchType:  "wildcard",
			Confidence: confidence,
		}
	}

	return nil
}

func matchSemanticVersionRange(version, versionRange string) (bool, float64) {
	// Handle common semver patterns
	patterns := map[string]*regexp.Regexp{
		">=": regexp.MustCompile(`^>=\s*(.+)`),
		"<=": regexp.MustCompile(`^<=\s*(.+)`),
		">":  regexp.MustCompile(`^>\s*(.+)`),
		"<":  regexp.MustCompile(`^<\s*(.+)`),
		"^":  regexp.MustCompile(`^\^\s*(.+)`),
		"~":  regexp.MustCompile(`^~\s*(.+)`),
	}

	for operator, pattern := range patterns {
		if matches := pattern.FindStringSubmatch(versionRange); matches != nil {
			targetVersion := matches[1]
			return compareVersions(version, targetVersion, operator), 0.8
		}
	}

	return false, 0.0
}

func matchWildcardRange(version, versionRange string) (bool, float64) {
	// Simple wildcard matching
	if strings.Contains(versionRange, "*") {
		pattern := strings.ReplaceAll(versionRange, "*", ".*")
		regex, err := regexp.Compile("^" + pattern + "$")
		if err != nil {
			return false, 0.0
		}
		return regex.MatchString(version), 0.6
	}
	return false, 0.0
}

func compareVersions(version1, version2, operator string) bool {
	// Simplified version comparison - in production, use a proper semver library
	v1Parts := parseVersionParts(version1)
	v2Parts := parseVersionParts(version2)

	comparison := compareVersionParts(v1Parts, v2Parts)

	switch operator {
	case ">=":
		return comparison >= 0
	case "<=":
		return comparison <= 0
	case ">":
		return comparison > 0
	case "<":
		return comparison < 0
	case "^":
		// Compatible release (same major version)
		return v1Parts[0] == v2Parts[0] && comparison >= 0
	case "~":
		// Reasonably close (same major and minor version)
		return v1Parts[0] == v2Parts[0] && v1Parts[1] == v2Parts[1] && comparison >= 0
	default:
		return false
	}
}

func parseVersionParts(version string) []int {
	// Remove leading 'v' if present
	version = strings.TrimPrefix(version, "v")
	
	parts := strings.Split(version, ".")
	var result []int
	
	for i, part := range parts {
		if i >= 3 {
			break // Only consider major.minor.patch
		}
		// Extract numeric part (ignore pre-release suffixes)
		numStr := regexp.MustCompile(`^\d+`).FindString(part)
		if numStr == "" {
			result = append(result, 0)
		} else {
			num, _ := strconv.Atoi(numStr)
			result = append(result, num)
		}
	}
	
	// Ensure we have at least 3 parts
	for len(result) < 3 {
		result = append(result, 0)
	}
	
	return result
}

func compareVersionParts(v1, v2 []int) int {
	for i := 0; i < 3; i++ {
		if v1[i] < v2[i] {
			return -1
		} else if v1[i] > v2[i] {
			return 1
		}
	}
	return 0
}

func deduplicateVulnerabilities(vulns []Vulnerability) []Vulnerability {
	seen := make(map[string]bool)
	var result []Vulnerability

	for _, vuln := range vulns {
		if !seen[vuln.ID] {
			seen[vuln.ID] = true
			result = append(result, vuln)
		}
	}

	return result
}

func extractCVSSVector(reference string) string {
	// Extract CVSS vector from reference string
	patterns := []string{
		`CVSS:3\.[01]/([A-Z]+:[A-Z]+/)*[A-Z]+:[A-Z]+`,
		`CVSS:2\.0/([A-Z]+:[A-Z]+/)*[A-Z]+:[A-Z]+`,
	}

	for _, pattern := range patterns {
		regex := regexp.MustCompile(pattern)
		if match := regex.FindString(reference); match != "" {
			return match
		}
	}

	return ""
}

func parseCVSSVector(vector string) map[string]string {
	metrics := make(map[string]string)
	
	// Simple CVSS vector parsing
	parts := strings.Split(vector, "/")
	for _, part := range parts[1:] { // Skip the version part
		if kv := strings.Split(part, ":"); len(kv) == 2 {
			metrics[kv[0]] = kv[1]
		}
	}
	
	return metrics
}

func calculateSeverityCategory(cvss float64) string {
	switch {
	case cvss >= 9.0:
		return "critical"
	case cvss >= 7.0:
		return "high"
	case cvss >= 4.0:
		return "medium"
	case cvss > 0.0:
		return "low"
	default:
		return "unknown"
	}
}

func calculateAlertPriority(cvss, confidence float64) string {
	score := cvss * confidence

	switch {
	case score >= 8.5:
		return "immediate"
	case score >= 7.0:
		return "urgent"
	case score >= 5.0:
		return "high"
	case score >= 3.0:
		return "medium"
	default:
		return "low"
	}
}

func generateRemediationSteps(match VulnerabilityMatch) []string {
	var steps []string

	// Check if patches are available
	if len(match.Vulnerability.PatchedIn) > 0 {
		latestPatch := match.Vulnerability.PatchedIn[len(match.Vulnerability.PatchedIn)-1]
		steps = append(steps, fmt.Sprintf("Update %s to version %s or later", match.PackageName, latestPatch))
	}

	// Add general remediation steps
	steps = append(steps, "Review dependency tree for alternative packages")
	steps = append(steps, "Check for security patches in package maintainer repository")
	steps = append(steps, "Consider temporarily removing or replacing the vulnerable package")

	if match.Vulnerability.CVSS >= 7.0 {
		steps = append(steps, "Apply this fix immediately due to high severity")
	}

	return steps
}

func estimateEffort(match VulnerabilityMatch) string {
	// Simple effort estimation based on vulnerability characteristics
	if len(match.Vulnerability.PatchedIn) > 0 {
		return "low" // Simple version update
	}
	if match.Vulnerability.CVSS >= 7.0 {
		return "high" // Critical vulnerability may require significant changes
	}
	return "medium" // Default estimation
}

func assessBusinessImpact(match VulnerabilityMatch) string {
	// Simple business impact assessment based on CVSS score
	switch {
	case match.Vulnerability.CVSS >= 8.0:
		return "critical"
	case match.Vulnerability.CVSS >= 6.0:
		return "high"
	case match.Vulnerability.CVSS >= 4.0:
		return "medium"
	default:
		return "low"
	}
}

// Memory cache implementation

func (mc *MemoryVulnerabilityCache) Get(key string) ([]Vulnerability, bool) {
	entry, exists := mc.cache[key]
	if !exists || time.Now().After(entry.expiry) {
		delete(mc.cache, key)
		return nil, false
	}
	return entry.vulnerabilities, true
}

func (mc *MemoryVulnerabilityCache) Set(key string, vulns []Vulnerability, ttl time.Duration) {
	mc.cache[key] = vulnCacheEntry{
		vulnerabilities: vulns,
		expiry:          time.Now().Add(ttl),
	}
}

func (mc *MemoryVulnerabilityCache) Clear() {
	mc.cache = make(map[string]vulnCacheEntry)
}

func (mc *MemoryVulnerabilityCache) Size() int {
	return len(mc.cache)
}