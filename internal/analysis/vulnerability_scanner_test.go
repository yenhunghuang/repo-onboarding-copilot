package analysis

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewVulnerabilityDatabase(t *testing.T) {
	db, err := NewVulnerabilityDatabase()
	require.NoError(t, err)
	assert.NotNil(t, db)
	assert.NotNil(t, db.client)
	assert.Len(t, db.sources, 3) // NPM, GitHub, OSV sources
	assert.NotNil(t, db.cache)

	defer db.Close()
}

func TestParsePackageSpec(t *testing.T) {
	tests := []struct {
		name            string
		spec            string
		expectedName    string
		expectedVersion string
		shouldError     bool
	}{
		{
			name:            "simple_package",
			spec:            "lodash@4.17.21",
			expectedName:    "lodash",
			expectedVersion: "4.17.21",
		},
		{
			name:            "scoped_package",
			spec:            "@types/node@16.0.0",
			expectedName:    "@types/node",
			expectedVersion: "16.0.0",
		},
		{
			name:            "complex_version",
			spec:            "package@1.0.0-beta.1",
			expectedName:    "package",
			expectedVersion: "1.0.0-beta.1",
		},
		{
			name:        "invalid_spec",
			spec:        "invalid-package",
			shouldError: true,
		},
		{
			name:            "multiple_at_signs",
			spec:            "@scope/package@1.0.0@extra",
			expectedName:    "@scope/package",
			expectedVersion: "1.0.0@extra",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			name, version, err := parsePackageSpec(tt.spec)

			if tt.shouldError {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.expectedName, name)
			assert.Equal(t, tt.expectedVersion, version)
		})
	}
}

func TestMatchVersionToRange(t *testing.T) {
	tests := []struct {
		name         string
		version      string
		versionRange string
		expectedType string
		shouldMatch  bool
	}{
		{
			name:         "exact_match",
			version:      "1.0.0",
			versionRange: "1.0.0",
			expectedType: "exact",
			shouldMatch:  true,
		},
		{
			name:         "greater_than_match",
			version:      "1.5.0",
			versionRange: ">1.0.0",
			expectedType: "range",
			shouldMatch:  true,
		},
		{
			name:         "greater_than_no_match",
			version:      "0.5.0",
			versionRange: ">1.0.0",
			shouldMatch:  false,
		},
		{
			name:         "caret_match",
			version:      "1.2.3",
			versionRange: "^1.0.0",
			expectedType: "range",
			shouldMatch:  true,
		},
		{
			name:         "caret_no_match",
			version:      "2.0.0",
			versionRange: "^1.0.0",
			shouldMatch:  false,
		},
		{
			name:         "tilde_match",
			version:      "1.2.5",
			versionRange: "~1.2.0",
			expectedType: "range",
			shouldMatch:  true,
		},
		{
			name:         "wildcard_match",
			version:      "1.5.3",
			versionRange: "1.*",
			expectedType: "wildcard",
			shouldMatch:  true,
		},
		{
			name:         "no_match",
			version:      "2.0.0",
			versionRange: "1.0.0",
			shouldMatch:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := matchVersionToRange(tt.version, tt.versionRange)

			if !tt.shouldMatch {
				assert.Nil(t, result)
				return
			}

			require.NotNil(t, result)
			assert.Equal(t, tt.expectedType, result.MatchType)
			assert.Greater(t, result.Confidence, 0.0)
		})
	}
}

func TestParseVersionParts(t *testing.T) {
	tests := []struct {
		name     string
		version  string
		expected []int
	}{
		{
			name:     "simple_version",
			version:  "1.2.3",
			expected: []int{1, 2, 3},
		},
		{
			name:     "version_with_v_prefix",
			version:  "v2.0.1",
			expected: []int{2, 0, 1},
		},
		{
			name:     "version_with_prerelease",
			version:  "1.0.0-alpha.1",
			expected: []int{1, 0, 0},
		},
		{
			name:     "partial_version",
			version:  "1.2",
			expected: []int{1, 2, 0},
		},
		{
			name:     "single_digit",
			version:  "5",
			expected: []int{5, 0, 0},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := parseVersionParts(tt.version)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestCompareVersionParts(t *testing.T) {
	tests := []struct {
		name     string
		v1       []int
		v2       []int
		expected int
	}{
		{
			name:     "equal_versions",
			v1:       []int{1, 0, 0},
			v2:       []int{1, 0, 0},
			expected: 0,
		},
		{
			name:     "v1_greater_major",
			v1:       []int{2, 0, 0},
			v2:       []int{1, 0, 0},
			expected: 1,
		},
		{
			name:     "v1_lesser_major",
			v1:       []int{1, 0, 0},
			v2:       []int{2, 0, 0},
			expected: -1,
		},
		{
			name:     "v1_greater_minor",
			v1:       []int{1, 2, 0},
			v2:       []int{1, 1, 0},
			expected: 1,
		},
		{
			name:     "v1_greater_patch",
			v1:       []int{1, 0, 2},
			v2:       []int{1, 0, 1},
			expected: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := compareVersionParts(tt.v1, tt.v2)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestCalculateSeverityCategory(t *testing.T) {
	tests := []struct {
		name     string
		cvss     float64
		expected string
	}{
		{
			name:     "critical",
			cvss:     9.5,
			expected: "critical",
		},
		{
			name:     "high",
			cvss:     7.5,
			expected: "high",
		},
		{
			name:     "medium",
			cvss:     5.0,
			expected: "medium",
		},
		{
			name:     "low",
			cvss:     2.5,
			expected: "low",
		},
		{
			name:     "unknown",
			cvss:     0.0,
			expected: "unknown",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := calculateSeverityCategory(tt.cvss)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestCalculateAlertPriority(t *testing.T) {
	tests := []struct {
		name       string
		cvss       float64
		confidence float64
		expected   string
	}{
		{
			name:       "immediate",
			cvss:       9.0,
			confidence: 1.0,
			expected:   "immediate",
		},
		{
			name:       "urgent",
			cvss:       8.0,
			confidence: 0.9,
			expected:   "urgent",
		},
		{
			name:       "high",
			cvss:       6.0,
			confidence: 0.8,
			expected:   "high",
		},
		{
			name:       "medium",
			cvss:       4.0,
			confidence: 0.7,
			expected:   "medium",
		},
		{
			name:       "low",
			cvss:       2.0,
			confidence: 0.5,
			expected:   "low",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := calculateAlertPriority(tt.cvss, tt.confidence)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestMemoryVulnerabilityCache(t *testing.T) {
	cache := &MemoryVulnerabilityCache{
		cache: make(map[string]vulnCacheEntry),
	}

	// Test empty cache
	vulns, found := cache.Get("test-key")
	assert.False(t, found)
	assert.Nil(t, vulns)
	assert.Equal(t, 0, cache.Size())

	// Test set and get
	testVulns := []Vulnerability{
		{
			ID:       "TEST-001",
			Title:    "Test Vulnerability",
			Severity: "high",
			CVSS:     7.5,
		},
	}

	cache.Set("test-key", testVulns, time.Hour)
	assert.Equal(t, 1, cache.Size())

	retrievedVulns, found := cache.Get("test-key")
	assert.True(t, found)
	assert.Equal(t, testVulns, retrievedVulns)

	// Test expiration
	cache.Set("expired-key", testVulns, -time.Hour) // Already expired
	_, found = cache.Get("expired-key")
	assert.False(t, found)

	// Test clear
	cache.Clear()
	assert.Equal(t, 0, cache.Size())
	_, found = cache.Get("test-key")
	assert.False(t, found)
}

func TestDeduplicateVulnerabilities(t *testing.T) {
	vulnerabilities := []Vulnerability{
		{ID: "CVE-2023-001", Title: "Vuln 1"},
		{ID: "CVE-2023-002", Title: "Vuln 2"},
		{ID: "CVE-2023-001", Title: "Vuln 1 Duplicate"}, // Duplicate
		{ID: "CVE-2023-003", Title: "Vuln 3"},
	}

	deduplicated := deduplicateVulnerabilities(vulnerabilities)

	assert.Len(t, deduplicated, 3)

	ids := make(map[string]bool)
	for _, vuln := range deduplicated {
		assert.False(t, ids[vuln.ID], "Found duplicate ID: %s", vuln.ID)
		ids[vuln.ID] = true
	}
}

func TestGenerateRemediationSteps(t *testing.T) {
	tests := []struct {
		name          string
		match         VulnerabilityMatch
		expectedSteps int
		shouldContain string
	}{
		{
			name: "with_patches",
			match: VulnerabilityMatch{
				PackageName: "lodash",
				Vulnerability: Vulnerability{
					PatchedIn: []string{"4.17.21"},
					CVSS:      5.0,
				},
			},
			expectedSteps: 4, // Update + 3 general steps
			shouldContain: "Update lodash to version 4.17.21",
		},
		{
			name: "high_severity",
			match: VulnerabilityMatch{
				PackageName: "express",
				Vulnerability: Vulnerability{
					PatchedIn: []string{"4.18.2"},
					CVSS:      8.5,
				},
			},
			expectedSteps: 5, // Update + 3 general + immediate action
			shouldContain: "Apply this fix immediately",
		},
		{
			name: "no_patches",
			match: VulnerabilityMatch{
				PackageName: "vulnerable-pkg",
				Vulnerability: Vulnerability{
					PatchedIn: []string{},
					CVSS:      6.0,
				},
			},
			expectedSteps: 3, // 3 general steps only
			shouldContain: "Review dependency tree",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			steps := generateRemediationSteps(tt.match)
			assert.Len(t, steps, tt.expectedSteps)

			found := false
			for _, step := range steps {
				if tt.shouldContain != "" && len(step) > 0 {
					if tt.shouldContain == "Update lodash to version 4.17.21" &&
						len(step) > 6 && step[:6] == "Update" {
						found = true
						break
					} else if tt.shouldContain == "Apply this fix immediately" &&
						len(step) > 5 && step[:5] == "Apply" {
						found = true
						break
					} else if tt.shouldContain == "Review dependency tree" &&
						len(step) > 6 && step[:6] == "Review" {
						found = true
						break
					}
				}
			}
			if tt.shouldContain != "" {
				assert.True(t, found, "Expected to find step containing: %s", tt.shouldContain)
			}
		})
	}
}

func TestEstimateEffort(t *testing.T) {
	tests := []struct {
		name     string
		match    VulnerabilityMatch
		expected string
	}{
		{
			name: "has_patches",
			match: VulnerabilityMatch{
				Vulnerability: Vulnerability{
					PatchedIn: []string{"1.0.1"},
					CVSS:      5.0,
				},
			},
			expected: "low",
		},
		{
			name: "high_severity_no_patches",
			match: VulnerabilityMatch{
				Vulnerability: Vulnerability{
					PatchedIn: []string{},
					CVSS:      8.0,
				},
			},
			expected: "high",
		},
		{
			name: "medium_severity_no_patches",
			match: VulnerabilityMatch{
				Vulnerability: Vulnerability{
					PatchedIn: []string{},
					CVSS:      5.0,
				},
			},
			expected: "medium",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := estimateEffort(tt.match)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestAssessBusinessImpact(t *testing.T) {
	tests := []struct {
		name     string
		match    VulnerabilityMatch
		expected string
	}{
		{
			name: "critical_impact",
			match: VulnerabilityMatch{
				Vulnerability: Vulnerability{CVSS: 9.0},
			},
			expected: "critical",
		},
		{
			name: "high_impact",
			match: VulnerabilityMatch{
				Vulnerability: Vulnerability{CVSS: 7.0},
			},
			expected: "high",
		},
		{
			name: "medium_impact",
			match: VulnerabilityMatch{
				Vulnerability: Vulnerability{CVSS: 5.0},
			},
			expected: "medium",
		},
		{
			name: "low_impact",
			match: VulnerabilityMatch{
				Vulnerability: Vulnerability{CVSS: 2.0},
			},
			expected: "low",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := assessBusinessImpact(tt.match)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// Integration test with mock vulnerability database
func TestVulnerabilityDatabaseIntegration(t *testing.T) {
	// This test demonstrates the integration flow
	// In a real environment, this would use actual vulnerability data

	db, err := NewVulnerabilityDatabase()
	require.NoError(t, err)
	defer db.Close()

	ctx := context.Background()
	packages := []string{"lodash@4.17.20", "express@4.17.0"}

	// This would typically return real vulnerabilities from the sources
	// For this test, we're verifying the integration structure works
	vulnerabilities, err := db.CheckVulnerabilities(ctx, packages)
	require.NoError(t, err)
	assert.NotNil(t, vulnerabilities)

	// Test vulnerability matching
	matches, err := db.MatchVulnerabilities(ctx, "lodash", "4.17.20")
	require.NoError(t, err)
	assert.NotNil(t, matches)

	// Test alert generation (with mock vulnerability)
	if len(vulnerabilities) > 0 {
		testMatch := VulnerabilityMatch{
			Vulnerability:  vulnerabilities[0],
			PackageName:    "test-package",
			PackageVersion: "1.0.0",
			Confidence:     0.9,
		}

		alert := db.GenerateAlert(testMatch)
		assert.NotNil(t, alert)
		assert.NotEmpty(t, alert.ID)
		assert.NotEmpty(t, alert.Priority)
		assert.NotEmpty(t, alert.RemediationSteps)
	}
}
