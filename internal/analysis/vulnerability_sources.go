// Package analysis provides vulnerability source integrations
package analysis

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// NPM Advisory API response structures
type NPMAuditResponse struct {
	Advisories map[string]NPMAdvisory `json:"advisories"`
	Metadata   NPMAuditMetadata       `json:"metadata"`
}

type NPMAdvisory struct {
	ID               int      `json:"id"`
	Title            string   `json:"title"`
	Overview         string   `json:"overview"`
	Severity         string   `json:"severity"`
	ModuleName       string   `json:"module_name"`
	VulnerableVersions string `json:"vulnerable_versions"`
	PatchedVersions    string `json:"patched_versions"`
	Recommendation     string `json:"recommendation"`
	References         string `json:"references"`
	CVEs               []string `json:"cves"`
	CWEs               []string `json:"cwes"`
	CVSSScore          float64  `json:"cvss_score"`
	Updated            string   `json:"updated"`
}

type NPMAuditMetadata struct {
	Vulnerabilities int `json:"vulnerabilities"`
	Dependencies    int `json:"dependencies"`
	DevDependencies int `json:"devDependencies"`
	TotalDependencies int `json:"totalDependencies"`
}

// GitHub Advisory API response structures
type GitHubAdvisoryResponse struct {
	Data struct {
		SecurityVulnerabilities struct {
			Nodes []GitHubAdvisory `json:"nodes"`
		} `json:"securityVulnerabilities"`
	} `json:"data"`
}

type GitHubAdvisory struct {
	Advisory struct {
		ID          string    `json:"ghsaId"`
		Summary     string    `json:"summary"`
		Description string    `json:"description"`
		Severity    string    `json:"severity"`
		CVEs        []struct {
			ID string `json:"id"`
		} `json:"cves"`
		CWEs []struct {
			CweID string `json:"cweId"`
		} `json:"cwes"`
		References []struct {
			URL string `json:"url"`
		} `json:"references"`
		PublishedAt time.Time `json:"publishedAt"`
	} `json:"advisory"`
	Package struct {
		Name      string `json:"name"`
		Ecosystem string `json:"ecosystem"`
	} `json:"package"`
	VulnerableVersionRange string `json:"vulnerableVersionRange"`
	FirstPatchedVersion    struct {
		Identifier string `json:"identifier"`
	} `json:"firstPatchedVersion"`
}

// OSV API response structures
type OSVResponse struct {
	Vulns []OSVVulnerability `json:"vulns"`
}

type OSVVulnerability struct {
	ID       string `json:"id"`
	Summary  string `json:"summary"`
	Details  string `json:"details"`
	Severity []struct {
		Type  string  `json:"type"`
		Score string  `json:"score"`
	} `json:"severity"`
	Affected []struct {
		Package struct {
			Name      string `json:"name"`
			Ecosystem string `json:"ecosystem"`
		} `json:"package"`
		Ranges []struct {
			Type   string `json:"type"`
			Events []struct {
				Introduced string `json:"introduced,omitempty"`
				Fixed      string `json:"fixed,omitempty"`
			} `json:"events"`
		} `json:"ranges"`
		Versions []string `json:"versions,omitempty"`
	} `json:"affected"`
	References []struct {
		Type string `json:"type"`
		URL  string `json:"url"`
	} `json:"references"`
	DatabaseSpecific map[string]interface{} `json:"database_specific,omitempty"`
}

// NPM Advisory Source Implementation

func (nas *NPMAdvisorySource) GetName() string {
	return "npm-advisory"
}

func (nas *NPMAdvisorySource) GetLastUpdate() time.Time {
	return nas.lastUpdate
}

func (nas *NPMAdvisorySource) QueryVulnerabilities(ctx context.Context, packageName, version string) ([]Vulnerability, error) {
	// Create audit request payload
	auditPayload := map[string]interface{}{
		"name":         "temp-audit",
		"version":      "1.0.0",
		"dependencies": map[string]string{
			packageName: version,
		},
		"dev":      false,
		"requires": map[string]interface{}{},
	}

	payload, err := json.Marshal(auditPayload)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal audit payload: %w", err)
	}

	// Make request to npm audit API
	req, err := http.NewRequestWithContext(ctx, "POST", nas.baseURL, bytes.NewBuffer(payload))
	if err != nil {
		return nil, fmt.Errorf("failed to create audit request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "repo-onboarding-copilot/1.0")

	resp, err := nas.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute audit request: %w", err)
	}
	defer resp.Body.Close()

	// Handle successful responses and expected 4xx responses (which indicate vulnerabilities found)
	if resp.StatusCode != http.StatusOK && resp.StatusCode < 400 || resp.StatusCode >= 500 {
		return nil, fmt.Errorf("npm audit API returned status: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read audit response: %w", err)
	}

	var auditResponse NPMAuditResponse
	if err := json.Unmarshal(body, &auditResponse); err != nil {
		return nil, fmt.Errorf("failed to parse audit response: %w", err)
	}

	// Convert NPM advisories to common vulnerability format
	var vulnerabilities []Vulnerability
	for _, advisory := range auditResponse.Advisories {
		vuln := convertNPMAdvisoryToVulnerability(advisory)
		vulnerabilities = append(vulnerabilities, vuln)
	}

	nas.lastUpdate = time.Now()
	return vulnerabilities, nil
}

func (nas *NPMAdvisorySource) UpdateCache(ctx context.Context) error {
	// NPM Advisory doesn't require explicit cache updates as it's queried per-package
	return nil
}

// GitHub Advisory Source Implementation

func (gas *GitHubAdvisorySource) GetName() string {
	return "github-advisory"
}

func (gas *GitHubAdvisorySource) GetLastUpdate() time.Time {
	return gas.lastUpdate
}

func (gas *GitHubAdvisorySource) QueryVulnerabilities(ctx context.Context, packageName, version string) ([]Vulnerability, error) {
	// GraphQL query for GitHub Security Advisory
	query := `
	query($ecosystem: SecurityAdvisoryEcosystem!, $package: String!) {
		securityVulnerabilities(
			first: 100,
			ecosystem: $ecosystem,
			package: $package
		) {
			nodes {
				advisory {
					ghsaId
					summary
					description
					severity
					cves {
						id
					}
					cwes {
						cweId
					}
					references {
						url
					}
					publishedAt
				}
				package {
					name
					ecosystem
				}
				vulnerableVersionRange
				firstPatchedVersion {
					identifier
				}
			}
		}
	}`

	variables := map[string]interface{}{
		"ecosystem": "NPM",
		"package":   packageName,
	}

	requestBody := map[string]interface{}{
		"query":     query,
		"variables": variables,
	}

	payload, err := json.Marshal(requestBody)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal GraphQL request: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", gas.baseURL, bytes.NewBuffer(payload))
	if err != nil {
		return nil, fmt.Errorf("failed to create GitHub request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "repo-onboarding-copilot/1.0")
	if gas.apiToken != "" {
		req.Header.Set("Authorization", "Bearer "+gas.apiToken)
	}

	resp, err := gas.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute GitHub request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("GitHub API returned status: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read GitHub response: %w", err)
	}

	var githubResponse GitHubAdvisoryResponse
	if err := json.Unmarshal(body, &githubResponse); err != nil {
		return nil, fmt.Errorf("failed to parse GitHub response: %w", err)
	}

	// Convert GitHub advisories to common vulnerability format
	var vulnerabilities []Vulnerability
	for _, advisory := range githubResponse.Data.SecurityVulnerabilities.Nodes {
		vuln := convertGitHubAdvisoryToVulnerability(advisory)
		vulnerabilities = append(vulnerabilities, vuln)
	}

	gas.lastUpdate = time.Now()
	return vulnerabilities, nil
}

func (gas *GitHubAdvisorySource) UpdateCache(ctx context.Context) error {
	// GitHub Advisory data is queried per-package, no explicit cache update needed
	return nil
}

// OSV Source Implementation

func (os *OSVSource) GetName() string {
	return "osv"
}

func (os *OSVSource) GetLastUpdate() time.Time {
	return os.lastUpdate
}

func (os *OSVSource) QueryVulnerabilities(ctx context.Context, packageName, version string) ([]Vulnerability, error) {
	// OSV query payload
	queryPayload := map[string]interface{}{
		"package": map[string]string{
			"name":      packageName,
			"ecosystem": "npm",
		},
		"version": version,
	}

	payload, err := json.Marshal(queryPayload)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal OSV query: %w", err)
	}

	url := fmt.Sprintf("%s/query", os.baseURL)
	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(payload))
	if err != nil {
		return nil, fmt.Errorf("failed to create OSV request: %w", err)
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "repo-onboarding-copilot/1.0")

	resp, err := os.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute OSV request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("OSV API returned status: %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read OSV response: %w", err)
	}

	var osvResponse OSVResponse
	if err := json.Unmarshal(body, &osvResponse); err != nil {
		return nil, fmt.Errorf("failed to parse OSV response: %w", err)
	}

	// Convert OSV vulnerabilities to common vulnerability format
	var vulnerabilities []Vulnerability
	for _, osvVuln := range osvResponse.Vulns {
		vuln := convertOSVVulnerabilityToVulnerability(osvVuln)
		vulnerabilities = append(vulnerabilities, vuln)
	}

	os.lastUpdate = time.Now()
	return vulnerabilities, nil
}

func (os *OSVSource) UpdateCache(ctx context.Context) error {
	// OSV data is queried per-package, no explicit cache update needed
	return nil
}

// Conversion functions

func convertNPMAdvisoryToVulnerability(advisory NPMAdvisory) Vulnerability {
	var references []string
	if advisory.References != "" {
		references = strings.Split(advisory.References, "\n")
	}

	var patchedVersions []string
	if advisory.PatchedVersions != "" {
		patchedVersions = strings.Split(advisory.PatchedVersions, ",")
		for i, v := range patchedVersions {
			patchedVersions[i] = strings.TrimSpace(v)
		}
	}

	var affectedVersions []string
	if advisory.VulnerableVersions != "" {
		affectedVersions = []string{advisory.VulnerableVersions}
	}

	return Vulnerability{
		ID:          fmt.Sprintf("NPM-%d", advisory.ID),
		Title:       advisory.Title,
		Description: advisory.Overview,
		Severity:    advisory.Severity,
		CVSS:        advisory.CVSSScore,
		CWE:         advisory.CWEs,
		References:  references,
		PatchedIn:   patchedVersions,
		AffectedIn:  affectedVersions,
		Metadata: map[string]string{
			"source":         "npm-advisory",
			"module_name":    advisory.ModuleName,
			"recommendation": advisory.Recommendation,
			"updated":        advisory.Updated,
		},
	}
}

func convertGitHubAdvisoryToVulnerability(advisory GitHubAdvisory) Vulnerability {
	var references []string
	for _, ref := range advisory.Advisory.References {
		references = append(references, ref.URL)
	}

	var cves []string
	for _, cve := range advisory.Advisory.CVEs {
		cves = append(cves, cve.ID)
	}

	var cwes []string
	for _, cwe := range advisory.Advisory.CWEs {
		cwes = append(cwes, cwe.CweID)
	}

	var patchedVersions []string
	if advisory.FirstPatchedVersion.Identifier != "" {
		patchedVersions = []string{advisory.FirstPatchedVersion.Identifier}
	}

	var affectedVersions []string
	if advisory.VulnerableVersionRange != "" {
		affectedVersions = []string{advisory.VulnerableVersionRange}
	}

	// Extract CVSS score from severity (simplified mapping)
	cvssScore := mapSeverityToCVSS(advisory.Advisory.Severity)

	return Vulnerability{
		ID:          advisory.Advisory.ID,
		Title:       advisory.Advisory.Summary,
		Description: advisory.Advisory.Description,
		Severity:    strings.ToLower(advisory.Advisory.Severity),
		CVSS:        cvssScore,
		CWE:         cwes,
		References:  references,
		PatchedIn:   patchedVersions,
		AffectedIn:  affectedVersions,
		Metadata: map[string]string{
			"source":        "github-advisory",
			"package_name":  advisory.Package.Name,
			"ecosystem":     advisory.Package.Ecosystem,
			"published_at":  advisory.Advisory.PublishedAt.Format(time.RFC3339),
		},
	}
}

func convertOSVVulnerabilityToVulnerability(osvVuln OSVVulnerability) Vulnerability {
	var references []string
	for _, ref := range osvVuln.References {
		references = append(references, ref.URL)
	}

	var cvssScore float64
	var severity string
	for _, sev := range osvVuln.Severity {
		if sev.Type == "CVSS_V3" {
			// Parse CVSS score from vector string
			if score := extractCVSSScoreFromVector(sev.Score); score > 0 {
				cvssScore = score
				severity = calculateSeverityCategory(score)
			}
		}
	}

	var patchedVersions []string
	var affectedVersions []string

	for _, affected := range osvVuln.Affected {
		for _, r := range affected.Ranges {
			for _, event := range r.Events {
				if event.Fixed != "" {
					patchedVersions = append(patchedVersions, event.Fixed)
				}
				if event.Introduced != "" {
					if event.Introduced == "0" {
						affectedVersions = append(affectedVersions, "*")
					} else {
						affectedVersions = append(affectedVersions, ">="+event.Introduced)
					}
				}
			}
		}
		// Add explicitly listed affected versions
		affectedVersions = append(affectedVersions, affected.Versions...)
	}

	return Vulnerability{
		ID:          osvVuln.ID,
		Title:       osvVuln.Summary,
		Description: osvVuln.Details,
		Severity:    severity,
		CVSS:        cvssScore,
		CWE:         []string{}, // OSV doesn't always provide CWE IDs
		References:  references,
		PatchedIn:   patchedVersions,
		AffectedIn:  affectedVersions,
		Metadata: map[string]string{
			"source": "osv",
		},
	}
}

// Helper functions

func mapSeverityToCVSS(severity string) float64 {
	// Simple mapping from GitHub severity to estimated CVSS score
	switch strings.ToUpper(severity) {
	case "CRITICAL":
		return 9.0
	case "HIGH":
		return 7.5
	case "MODERATE", "MEDIUM":
		return 5.0
	case "LOW":
		return 2.5
	default:
		return 0.0
	}
}

func extractCVSSScoreFromVector(vector string) float64 {
	// Extract base score from CVSS vector string
	// This is a simplified implementation - in production, use a proper CVSS library
	if strings.Contains(vector, "CVSS:") {
		// Look for score in the vector or try to calculate from components
		// For now, return a default based on severity metrics
		if strings.Contains(vector, "AV:N") && strings.Contains(vector, "AC:L") {
			return 7.5 // High severity for network-accessible, low complexity
		}
		return 5.0 // Medium severity default
	}
	return 0.0
}