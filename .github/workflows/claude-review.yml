name: Claude Code Auto Review

on:
  pull_request:
    types: [opened, synchronize]
    branches: [ main, develop ]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  claude-review:
    name: Claude Code Review
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v40
        with:
          files: |
            **/*.go
            **/*.js
            **/*.ts
            **/*.py
            **/*.java
            **/*.md
            **/Dockerfile*
            **/*.yml
            **/*.yaml

      - name: Claude Code Analysis
        if: steps.changed-files.outputs.any_changed == 'true'
        uses: actions/github-script@v7
        env:
          CLAUDE_GUIDELINES: |
            # Claude Code Review Guidelines
            
            æ ¹æ“š CLAUDE.md è¦ç¯„é€²è¡Œç¨‹å¼ç¢¼å¯©æŸ¥ï¼š
            
            ## å¯©æŸ¥é‡é»
            1. **å®‰å…¨æ€§å•é¡Œ**: SQL injection, XSS, è·¯å¾‘éæ­·, æ•æ„Ÿè³‡è¨Šæ´©éœ²
            2. **æ•ˆèƒ½å•é¡Œ**: N+1 queries, è¨˜æ†¶é«”æ´©æ¼, ç„¡é™è¿´åœˆ
            3. **ç¨‹å¼ç¢¼å“è³ª**: éµå¾ª SOLID åŸå‰‡, éŒ¯èª¤è™•ç†, æ¸¬è©¦è¦†è“‹
            4. **æ¶æ§‹ä¸€è‡´æ€§**: ç¬¦åˆå°ˆæ¡ˆæ¶æ§‹æ¨¡å¼, ä¾è³´æ³¨å…¥æ­£ç¢ºæ€§
            5. **API è¨­è¨ˆ**: RESTful åŸå‰‡, éŒ¯èª¤å›æ‡‰æ ¼å¼, ç‰ˆæœ¬æ§åˆ¶
            
            ## å›æ‡‰æ ¼å¼
            - åªåœ¨æœ‰ä¿®æ”¹çš„è¡Œç•™ä¸‹å…·é«”å»ºè­°
            - æä¾›ç¨‹å¼ç¢¼ç¯„ä¾‹èªªæ˜æ”¹é€²æ–¹å¼  
            - æ¨™è¨»åš´é‡ç¨‹åº¦: ğŸš¨ Critical | âš ï¸ Warning | ğŸ’¡ Suggestion
            - åŒ…å«ç›¸é—œæ–‡ä»¶é€£çµæˆ–æœ€ä½³å¯¦è¸åƒè€ƒ
            
            ## ä¸è¦åš
            - é¢¨æ ¼åå¥½çš„è©•è«– (å·²æœ‰ linter è™•ç†)
            - éåº¦ç´°ç¯€çš„èªæ³•å»ºè­°
            - æ²’æœ‰å¯¦è³ªå¹«åŠ©çš„ä¸€èˆ¬æ€§è©•è«–
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // ç²å– PR è³‡è¨Š
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            // ç²å–æª”æ¡ˆå·®ç•°
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
            });
            
            const changedFiles = '${{ steps.changed-files.outputs.all_changed_files }}';
            if (!changedFiles) {
              console.log('No relevant files changed');
              return;
            }
            
            // åˆ†ææ¯å€‹è®Šæ›´çš„æª”æ¡ˆ
            const reviewComments = [];
            let hasErrors = false;
            let hasWarnings = false;
            
            for (const file of files) {
              if (file.status === 'removed') continue;
              
              const fileExtension = path.extname(file.filename);
              const patch = file.patch || '';
              
              // å®‰å…¨æ€§æª¢æŸ¥
              const securityIssues = analyzeSecurityIssues(file.filename, patch);
              if (securityIssues.length > 0) {
                hasErrors = true;
                reviewComments.push(...securityIssues);
              }
              
              // æ•ˆèƒ½æª¢æŸ¥
              const performanceIssues = analyzePerformanceIssues(file.filename, patch);
              if (performanceIssues.length > 0) {
                hasWarnings = true;
                reviewComments.push(...performanceIssues);
              }
              
              // Go èªè¨€ç‰¹å®šæª¢æŸ¥
              if (fileExtension === '.go') {
                const goIssues = analyzeGoCode(file.filename, patch);
                reviewComments.push(...goIssues);
              }
              
              // Docker æª¢æŸ¥
              if (file.filename.includes('Dockerfile')) {
                const dockerIssues = analyzeDockerfile(file.filename, patch);
                reviewComments.push(...dockerIssues);
              }
            }
            
            // å®‰å…¨æ€§å•é¡Œåˆ†æå‡½æ•¸
            function analyzeSecurityIssues(filename, patch) {
              const issues = [];
              const lines = patch.split('\n');
              
              lines.forEach((line, index) => {
                if (!line.startsWith('+')) return;
                
                // SQL Injection æª¢æŸ¥
                if (line.match(/fmt\.Sprintf.*SELECT|UPDATE|DELETE|INSERT/i)) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'ğŸš¨ Critical',
                    message: 'Possible SQL injection vulnerability. Use parameterized queries instead of string formatting.',
                    suggestion: 'Use prepared statements: `db.Query("SELECT * FROM users WHERE id = ?", userID)`'
                  });
                }
                
                // ç¡¬ç·¨ç¢¼å¯†é‘°æª¢æŸ¥
                if (line.match(/password|secret|key.*=.*["\'][^"\']{8,}["\']|token.*=.*["\'][^"\']{20,}["\']/) && 
                    !line.includes('example') && !line.includes('test')) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'ğŸš¨ Critical',
                    message: 'Hard-coded secrets detected. Move sensitive data to environment variables.',
                    suggestion: 'Use: `password := os.Getenv("DB_PASSWORD")`'
                  });
                }
                
                // è·¯å¾‘éæ­·æª¢æŸ¥
                if (line.match(/filepath\.Join.*\.\.|os\.Open.*\.\.|ioutil\.ReadFile.*\.\./) && 
                    !line.includes('filepath.Clean')) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'âš ï¸ Warning',
                    message: 'Potential path traversal vulnerability. Validate and sanitize file paths.',
                    suggestion: 'Use: `filepath.Clean()` and validate against allowed directories'
                  });
                }
              });
              
              return issues;
            }
            
            // æ•ˆèƒ½å•é¡Œåˆ†æå‡½æ•¸
            function analyzePerformanceIssues(filename, patch) {
              const issues = [];
              const lines = patch.split('\n');
              
              lines.forEach((line, index) => {
                if (!line.startsWith('+')) return;
                
                // è¿´åœˆä¸­çš„ Query æª¢æŸ¥ (N+1 å•é¡Œ)
                if (line.includes('for') && patch.includes('Query(') && 
                    patch.slice(patch.indexOf(line)).includes('Query(')) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'âš ï¸ Warning',
                    message: 'Possible N+1 query problem. Consider using JOIN or batch queries.',
                    suggestion: 'Use batch queries or preload relationships to avoid multiple database calls'
                  });
                }
                
                // ç„¡é™åˆ¶çš„ goroutine å»ºç«‹
                if (line.match(/go\s+func|go\s+\w+/) && !patch.includes('sync.WaitGroup') && 
                    !patch.includes('context') && !patch.includes('semaphore')) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'ğŸ’¡ Suggestion',
                    message: 'Consider using worker pools or context cancellation for goroutine management.',
                    suggestion: 'Use `sync.WaitGroup` or implement worker pool pattern'
                  });
                }
              });
              
              return issues;
            }
            
            // Go ç¨‹å¼ç¢¼ç‰¹å®šæª¢æŸ¥
            function analyzeGoCode(filename, patch) {
              const issues = [];
              const lines = patch.split('\n');
              
              lines.forEach((line, index) => {
                if (!line.startsWith('+')) return;
                
                // éŒ¯èª¤è™•ç†æª¢æŸ¥
                if (line.includes(':= ') && line.includes('err') && 
                    !patch.includes('if err != nil')) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'âš ï¸ Warning',
                    message: 'Error not handled. Always check and handle errors appropriately.',
                    suggestion: 'Add: `if err != nil { return err }` or proper error handling'
                  });
                }
                
                // ç©º interface{} ä½¿ç”¨æª¢æŸ¥
                if (line.includes('interface{}') && !line.includes('//')) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'ğŸ’¡ Suggestion',
                    message: 'Consider using specific types or generics instead of empty interface.',
                    suggestion: 'Use concrete types or `any` (Go 1.18+) for better type safety'
                  });
                }
              });
              
              return issues;
            }
            
            // Dockerfile æª¢æŸ¥
            function analyzeDockerfile(filename, patch) {
              const issues = [];
              const lines = patch.split('\n');
              
              lines.forEach((line, index) => {
                if (!line.startsWith('+')) return;
                
                // ROOT ä½¿ç”¨è€…æª¢æŸ¥
                if (line.match(/^FROM.*/) && !patch.includes('USER ')) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'âš ï¸ Warning',
                    message: 'Running as root user. Add non-root user for security.',
                    suggestion: 'Add: `USER 1001` or create dedicated user'
                  });
                }
                
                // å¯†é‘°è¤‡è£½æª¢æŸ¥
                if (line.match(/COPY.*\.(key|pem|p12|jks)/) || line.match(/ADD.*\.(key|pem|p12|jks)/)) {
                  issues.push({
                    path: filename,
                    line: index + 1,
                    level: 'ğŸš¨ Critical',
                    message: 'Copying secret files into Docker image. Use secrets mounting instead.',
                    suggestion: 'Use Docker secrets or mount secrets at runtime'
                  });
                }
              });
              
              return issues;
            }
            
            // ç”¢ç”Ÿå¯©æŸ¥ç¸½çµ
            let summary = `## ğŸ¤– Claude Code Review Summary\n\n`;
            summary += `ğŸ“Š **Statistics:**\n`;
            summary += `- Files reviewed: ${files.length}\n`;
            summary += `- Issues found: ${reviewComments.length}\n`;
            summary += `- Critical issues: ${reviewComments.filter(c => c.level.includes('Critical')).length}\n`;
            summary += `- Warnings: ${reviewComments.filter(c => c.level.includes('Warning')).length}\n`;
            summary += `- Suggestions: ${reviewComments.filter(c => c.level.includes('Suggestion')).length}\n\n`;
            
            if (reviewComments.length === 0) {
              summary += `âœ… **No issues detected!** Code looks good to merge.\n\n`;
              summary += `All automated checks passed:\n`;
              summary += `- âœ… No security vulnerabilities found\n`;
              summary += `- âœ… No performance issues detected\n`;
              summary += `- âœ… Code follows best practices\n`;
            } else {
              summary += `### ğŸ“‹ Issues Overview:\n\n`;
              
              const criticalIssues = reviewComments.filter(c => c.level.includes('Critical'));
              const warningIssues = reviewComments.filter(c => c.level.includes('Warning'));
              const suggestions = reviewComments.filter(c => c.level.includes('Suggestion'));
              
              if (criticalIssues.length > 0) {
                summary += `ğŸš¨ **Critical Issues (Must Fix):**\n`;
                criticalIssues.forEach(issue => {
                  summary += `- \`${issue.path}:${issue.line}\` - ${issue.message}\n`;
                });
                summary += `\n`;
              }
              
              if (warningIssues.length > 0) {
                summary += `âš ï¸ **Warnings (Recommended Fix):**\n`;
                warningIssues.forEach(issue => {
                  summary += `- \`${issue.path}:${issue.line}\` - ${issue.message}\n`;
                });
                summary += `\n`;
              }
              
              if (suggestions.length > 0) {
                summary += `ğŸ’¡ **Suggestions (Optional):**\n`;
                suggestions.forEach(issue => {
                  summary += `- \`${issue.path}:${issue.line}\` - ${issue.message}\n`;
                });
                summary += `\n`;
              }
              
              if (hasErrors) {
                summary += `âŒ **Action Required:** Please fix critical issues before merging.\n`;
              } else if (hasWarnings) {
                summary += `âš ï¸ **Recommendation:** Consider addressing warnings for better code quality.\n`;
              } else {
                summary += `ğŸ‘ **Looking good!** Only minor suggestions found.\n`;
              }
            }
            
            summary += `\n---\n`;
            summary += `ğŸ”„ Auto-review completed in ${Date.now() - new Date(context.payload.pull_request.created_at).getTime()}ms\n`;
            summary += `ğŸ“ For detailed explanations, see inline comments below.\n`;
            
            // å»ºç«‹æˆ–æ›´æ–°è©•è«–
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.user.login === 'github-actions[bot]' && 
              comment.body.includes('Claude Code Review Summary')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
            }
            
            // è¨­å®š PR ç‹€æ…‹
            const state = hasErrors ? 'failure' : hasWarnings ? 'success' : 'success';
            const description = hasErrors ? 
              'Critical issues found - review required' : 
              hasWarnings ? 
              'Warnings found - review recommended' : 
              'No issues found';
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              target_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/pull/${context.issue.number}`,
              description: description,
              context: 'Claude Code Review'
            });

      - name: Auto-fix Minor Issues
        if: contains(github.event.pull_request.labels.*.name, 'auto-fix')
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log('ğŸ”§ Auto-fix mode enabled - applying minor fixes...');
            
            // é€™è£¡å¯ä»¥å¯¦ä½œè‡ªå‹•ä¿®æ­£é‚è¼¯
            // ä¾‹å¦‚ï¼šæ ¼å¼åŒ–ã€ç°¡å–®çš„èªæ³•ä¿®æ­£ç­‰
            
            // ç¤ºä¾‹ï¼šè‡ªå‹•æ ¼å¼åŒ– Go ç¨‹å¼ç¢¼
            const { execSync } = require('child_process');
            
            try {
              execSync('make fmt', { stdio: 'inherit' });
              
              // æª¢æŸ¥æ˜¯å¦æœ‰è®Šæ›´
              const gitStatus = execSync('git status --porcelain', { encoding: 'utf8' });
              
              if (gitStatus.trim()) {
                execSync('git config user.name "github-actions[bot]"');
                execSync('git config user.email "github-actions[bot]@users.noreply.github.com"');
                execSync('git add .');
                execSync('git commit -m "ğŸ¤– Auto-fix: Format code and minor fixes"');
                execSync('git push');
                
                // ç•™è¨€èªªæ˜è‡ªå‹•ä¿®æ­£
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: 'ğŸ¤– **Auto-fix Applied!**\n\nApplied automatic formatting and minor fixes:\n- Code formatting\n- Import organization\n- Simple syntax corrections\n\nPlease review the changes and re-run tests if needed.'
                });
              }
            } catch (error) {
              console.error('Auto-fix failed:', error.message);
            }