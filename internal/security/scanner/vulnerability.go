// Package scanner provides container image vulnerability scanning integration
// with support for Trivy and Clair scanners, security policy validation, and reporting.
package scanner

import (
	"context"
	"encoding/json"
	"fmt"
	"os/exec"
	"strings"
	"time"

	"github.com/yenhunghuang/repo-onboarding-copilot/pkg/logger"
)

// VulnerabilityScanner represents different vulnerability scanning engines
type VulnerabilityScanner string

const (
	// ScannerTrivy represents Aqua Trivy scanner
	ScannerTrivy VulnerabilityScanner = "trivy"
	// ScannerClair represents CoreOS Clair scanner
	ScannerClair VulnerabilityScanner = "clair"
)

// SeverityLevel represents vulnerability severity levels
type SeverityLevel string

const (
	SeverityUnknown  SeverityLevel = "UNKNOWN"
	SeverityLow      SeverityLevel = "LOW"
	SeverityMedium   SeverityLevel = "MEDIUM"
	SeverityHigh     SeverityLevel = "HIGH"
	SeverityCritical SeverityLevel = "CRITICAL"
)

// ScanConfig represents vulnerability scanning configuration
type ScanConfig struct {
	// Scanner settings
	Scanner VulnerabilityScanner `json:"scanner"`
	Timeout time.Duration        `json:"timeout"`

	// Security policy
	MaxCritical int `json:"max_critical"` // 0 = block all critical
	MaxHigh     int `json:"max_high"`     // 5 = allow up to 5 high
	MaxMedium   int `json:"max_medium"`   // 20 = allow up to 20 medium
	MaxLow      int `json:"max_low"`      // 100 = allow up to 100 low

	// Scanning options
	ScanOS        bool `json:"scan_os"`        // Scan OS packages
	ScanLibraries bool `json:"scan_libraries"` // Scan language libraries
	ScanSecrets   bool `json:"scan_secrets"`   // Scan for exposed secrets

	// Reporting
	GenerateReport bool   `json:"generate_report"`
	ReportFormat   string `json:"report_format"` // json, table, sarif

	// Cache settings
	CacheResults bool          `json:"cache_results"`
	CacheTTL     time.Duration `json:"cache_ttl"`
}

// Vulnerability represents a detected security vulnerability
type Vulnerability struct {
	ID          string        `json:"id"`
	Title       string        `json:"title"`
	Description string        `json:"description"`
	Severity    SeverityLevel `json:"severity"`
	Score       float64       `json:"score"` // CVSS score

	// Package information
	PackageName    string `json:"package_name"`
	PackageVersion string `json:"package_version"`
	FixedVersion   string `json:"fixed_version,omitempty"`

	// References
	References []string `json:"references,omitempty"`

	// Metadata
	PublishedDate time.Time `json:"published_date,omitempty"`
	LastModified  time.Time `json:"last_modified,omitempty"`
}

// ScanResult represents the results of a vulnerability scan
type ScanResult struct {
	ImageName string               `json:"image_name"`
	ScanTime  time.Time            `json:"scan_time"`
	Scanner   VulnerabilityScanner `json:"scanner"`

	// Vulnerabilities by severity
	Vulnerabilities []Vulnerability `json:"vulnerabilities"`

	// Summary counts
	TotalVulns    int `json:"total_vulnerabilities"`
	CriticalCount int `json:"critical_count"`
	HighCount     int `json:"high_count"`
	MediumCount   int `json:"medium_count"`
	LowCount      int `json:"low_count"`
	UnknownCount  int `json:"unknown_count"`

	// Policy evaluation
	PolicyViolations []PolicyViolation `json:"policy_violations"`
	PolicyPassed     bool              `json:"policy_passed"`

	// Execution metadata
	ScanDuration time.Duration `json:"scan_duration"`
	ErrorMessage string        `json:"error_message,omitempty"`
}

// PolicyViolation represents a security policy violation
type PolicyViolation struct {
	Rule        string        `json:"rule"`
	Severity    SeverityLevel `json:"severity"`
	Count       int           `json:"count"`
	Limit       int           `json:"limit"`
	Description string        `json:"description"`
}

// SecurityScanner manages vulnerability scanning operations
type SecurityScanner struct {
	config      *ScanConfig
	auditLogger *logger.Logger

	// Statistics
	TotalScans    int64
	PassedScans   int64
	FailedScans   int64
	CachedResults int64
}

// NewSecurityScanner creates a new vulnerability scanner
func NewSecurityScanner(auditLogger *logger.Logger) (*SecurityScanner, error) {
	if auditLogger == nil {
		return nil, fmt.Errorf("audit logger cannot be nil")
	}

	config := &ScanConfig{
		Scanner:        ScannerTrivy, // Default to Trivy
		Timeout:        10 * time.Minute,
		MaxCritical:    0,   // Block all critical vulnerabilities
		MaxHigh:        5,   // Allow up to 5 high severity
		MaxMedium:      20,  // Allow up to 20 medium severity
		MaxLow:         100, // Allow up to 100 low severity
		ScanOS:         true,
		ScanLibraries:  true,
		ScanSecrets:    true,
		GenerateReport: true,
		ReportFormat:   "json",
		CacheResults:   true,
		CacheTTL:       24 * time.Hour,
	}

	ss := &SecurityScanner{
		config:      config,
		auditLogger: auditLogger,
	}

	auditLogger.WithFields(map[string]interface{}{
		"operation":      "security_scanner_created",
		"scanner":        string(config.Scanner),
		"max_critical":   config.MaxCritical,
		"max_high":       config.MaxHigh,
		"max_medium":     config.MaxMedium,
		"scan_os":        config.ScanOS,
		"scan_libraries": config.ScanLibraries,
		"scan_secrets":   config.ScanSecrets,
		"timeout":        config.Timeout.Seconds(),
		"timestamp":      time.Now().Unix(),
	}).Info("Security scanner initialized")

	return ss, nil
}

// ScanImage performs vulnerability scanning on a container image
func (ss *SecurityScanner) ScanImage(ctx context.Context, imageName string) (*ScanResult, error) {
	if imageName == "" {
		return nil, fmt.Errorf("image name cannot be empty")
	}

	startTime := time.Now()
	ss.TotalScans++

	ss.auditLogger.WithFields(map[string]interface{}{
		"operation":  "vulnerability_scan_start",
		"image_name": imageName,
		"scanner":    string(ss.config.Scanner),
		"timestamp":  startTime.Unix(),
	}).Info("Starting vulnerability scan")

	// Initialize scan result
	result := &ScanResult{
		ImageName: imageName,
		ScanTime:  startTime,
		Scanner:   ss.config.Scanner,
	}

	// Perform the actual scan based on configured scanner
	var err error
	switch ss.config.Scanner {
	case ScannerTrivy:
		err = ss.scanWithTrivy(ctx, imageName, result)
	case ScannerClair:
		err = ss.scanWithClair(ctx, imageName, result)
	default:
		err = fmt.Errorf("unsupported scanner: %s", ss.config.Scanner)
	}

	result.ScanDuration = time.Since(startTime)

	if err != nil {
		result.ErrorMessage = err.Error()
		ss.FailedScans++

		ss.auditLogger.WithFields(map[string]interface{}{
			"operation":     "vulnerability_scan_failure",
			"image_name":    imageName,
			"scanner":       string(ss.config.Scanner),
			"error":         err.Error(),
			"scan_duration": result.ScanDuration.Seconds(),
			"timestamp":     time.Now().Unix(),
		}).Error("Vulnerability scan failed")

		return result, err
	}

	// Count vulnerabilities by severity
	ss.categorizeVulnerabilities(result)

	// Evaluate security policy
	ss.evaluateSecurityPolicy(result)

	if result.PolicyPassed {
		ss.PassedScans++
	} else {
		ss.FailedScans++
	}

	ss.auditLogger.WithFields(map[string]interface{}{
		"operation":             "vulnerability_scan_complete",
		"image_name":            imageName,
		"scanner":               string(ss.config.Scanner),
		"total_vulnerabilities": result.TotalVulns,
		"critical_count":        result.CriticalCount,
		"high_count":            result.HighCount,
		"medium_count":          result.MediumCount,
		"low_count":             result.LowCount,
		"policy_passed":         result.PolicyPassed,
		"policy_violations":     len(result.PolicyViolations),
		"scan_duration":         result.ScanDuration.Seconds(),
		"timestamp":             time.Now().Unix(),
	}).Info("Vulnerability scan completed")

	return result, nil
}

// scanWithTrivy performs vulnerability scanning using Trivy
func (ss *SecurityScanner) scanWithTrivy(ctx context.Context, imageName string, result *ScanResult) error {
	// Create timeout context
	scanCtx, cancel := context.WithTimeout(ctx, ss.config.Timeout)
	defer cancel()

	// Build Trivy command arguments
	args := []string{"image", "--format", "json", "--quiet"}

	// Add scan type flags
	if ss.config.ScanOS {
		args = append(args, "--scanners", "vuln")
	}
	if ss.config.ScanSecrets {
		args = append(args, "--scanners", "secret")
	}

	args = append(args, imageName)

	// Execute Trivy scan
	cmd := exec.CommandContext(scanCtx, "trivy", args...)
	output, err := cmd.CombinedOutput()

	if err != nil {
		return fmt.Errorf("trivy scan failed: %w, output: %s", err, string(output))
	}

	// Parse Trivy JSON output
	return ss.parseTrivyOutput(string(output), result)
}

// parseTrivyOutput parses Trivy JSON output into ScanResult
func (ss *SecurityScanner) parseTrivyOutput(output string, result *ScanResult) error {
	// Trivy output structure (simplified)
	type TrivyVuln struct {
		VulnerabilityID  string   `json:"VulnerabilityID"`
		Title            string   `json:"Title"`
		Description      string   `json:"Description"`
		Severity         string   `json:"Severity"`
		CVSS             float64  `json:"CVSS"`
		PkgName          string   `json:"PkgName"`
		InstalledVersion string   `json:"InstalledVersion"`
		FixedVersion     string   `json:"FixedVersion"`
		References       []string `json:"References"`
	}

	type TrivyResult struct {
		Vulnerabilities []TrivyVuln `json:"Vulnerabilities"`
	}

	type TrivyOutput struct {
		Results []TrivyResult `json:"Results"`
	}

	var trivyOutput TrivyOutput
	if err := json.Unmarshal([]byte(output), &trivyOutput); err != nil {
		return fmt.Errorf("failed to parse Trivy output: %w", err)
	}

	// Convert Trivy vulnerabilities to our format
	for _, trivyResult := range trivyOutput.Results {
		for _, vuln := range trivyResult.Vulnerabilities {
			vulnerability := Vulnerability{
				ID:             vuln.VulnerabilityID,
				Title:          vuln.Title,
				Description:    vuln.Description,
				Severity:       SeverityLevel(vuln.Severity),
				Score:          vuln.CVSS,
				PackageName:    vuln.PkgName,
				PackageVersion: vuln.InstalledVersion,
				FixedVersion:   vuln.FixedVersion,
				References:     vuln.References,
			}

			result.Vulnerabilities = append(result.Vulnerabilities, vulnerability)
		}
	}

	return nil
}

// scanWithClair performs vulnerability scanning using Clair (placeholder implementation)
func (ss *SecurityScanner) scanWithClair(ctx context.Context, imageName string, result *ScanResult) error {
	// This is a placeholder implementation for Clair integration
	// In a real implementation, this would interact with Clair's API
	ss.auditLogger.WithFields(map[string]interface{}{
		"operation":  "clair_scan_placeholder",
		"image_name": imageName,
		"timestamp":  time.Now().Unix(),
	}).Warn("Clair scanning not yet implemented - using placeholder")

	return fmt.Errorf("Clair scanning not yet implemented")
}

// categorizeVulnerabilities counts vulnerabilities by severity level
func (ss *SecurityScanner) categorizeVulnerabilities(result *ScanResult) {
	result.TotalVulns = len(result.Vulnerabilities)

	for _, vuln := range result.Vulnerabilities {
		switch vuln.Severity {
		case SeverityCritical:
			result.CriticalCount++
		case SeverityHigh:
			result.HighCount++
		case SeverityMedium:
			result.MediumCount++
		case SeverityLow:
			result.LowCount++
		default:
			result.UnknownCount++
		}
	}
}

// evaluateSecurityPolicy checks scan results against security policy
func (ss *SecurityScanner) evaluateSecurityPolicy(result *ScanResult) {
	result.PolicyPassed = true
	result.PolicyViolations = []PolicyViolation{}

	// Check critical vulnerabilities
	if result.CriticalCount > ss.config.MaxCritical {
		violation := PolicyViolation{
			Rule:        "max_critical_vulnerabilities",
			Severity:    SeverityCritical,
			Count:       result.CriticalCount,
			Limit:       ss.config.MaxCritical,
			Description: fmt.Sprintf("Found %d critical vulnerabilities, limit is %d", result.CriticalCount, ss.config.MaxCritical),
		}
		result.PolicyViolations = append(result.PolicyViolations, violation)
		result.PolicyPassed = false
	}

	// Check high severity vulnerabilities
	if result.HighCount > ss.config.MaxHigh {
		violation := PolicyViolation{
			Rule:        "max_high_vulnerabilities",
			Severity:    SeverityHigh,
			Count:       result.HighCount,
			Limit:       ss.config.MaxHigh,
			Description: fmt.Sprintf("Found %d high severity vulnerabilities, limit is %d", result.HighCount, ss.config.MaxHigh),
		}
		result.PolicyViolations = append(result.PolicyViolations, violation)
		result.PolicyPassed = false
	}

	// Check medium severity vulnerabilities
	if result.MediumCount > ss.config.MaxMedium {
		violation := PolicyViolation{
			Rule:        "max_medium_vulnerabilities",
			Severity:    SeverityMedium,
			Count:       result.MediumCount,
			Limit:       ss.config.MaxMedium,
			Description: fmt.Sprintf("Found %d medium severity vulnerabilities, limit is %d", result.MediumCount, ss.config.MaxMedium),
		}
		result.PolicyViolations = append(result.PolicyViolations, violation)
		result.PolicyPassed = false
	}

	// Check low severity vulnerabilities
	if result.LowCount > ss.config.MaxLow {
		violation := PolicyViolation{
			Rule:        "max_low_vulnerabilities",
			Severity:    SeverityLow,
			Count:       result.LowCount,
			Limit:       ss.config.MaxLow,
			Description: fmt.Sprintf("Found %d low severity vulnerabilities, limit is %d", result.LowCount, ss.config.MaxLow),
		}
		result.PolicyViolations = append(result.PolicyViolations, violation)
		result.PolicyPassed = false
	}
}

// ValidateImageSecurity performs complete security validation of an image
func (ss *SecurityScanner) ValidateImageSecurity(ctx context.Context, imageName string) error {
	result, err := ss.ScanImage(ctx, imageName)
	if err != nil {
		return fmt.Errorf("security scan failed: %w", err)
	}

	if !result.PolicyPassed {
		violationDetails := make([]string, len(result.PolicyViolations))
		for i, violation := range result.PolicyViolations {
			violationDetails[i] = violation.Description
		}

		return fmt.Errorf("image security validation failed: %s", strings.Join(violationDetails, "; "))
	}

	ss.auditLogger.WithFields(map[string]interface{}{
		"operation":     "image_security_validation_passed",
		"image_name":    imageName,
		"total_vulns":   result.TotalVulns,
		"scan_duration": result.ScanDuration.Seconds(),
		"timestamp":     time.Now().Unix(),
	}).Info("Image passed security validation")

	return nil
}

// GetScanStatistics returns current scanning statistics
func (ss *SecurityScanner) GetScanStatistics() map[string]interface{} {
	return map[string]interface{}{
		"total_scans":    ss.TotalScans,
		"passed_scans":   ss.PassedScans,
		"failed_scans":   ss.FailedScans,
		"cached_results": ss.CachedResults,
		"scanner":        string(ss.config.Scanner),
		"config":         ss.config,
		"timestamp":      time.Now().Unix(),
	}
}

// SetScanConfig updates the security scanning configuration
func (ss *SecurityScanner) SetScanConfig(config *ScanConfig) error {
	if config == nil {
		return fmt.Errorf("scan config cannot be nil")
	}

	if err := ss.validateScanConfig(config); err != nil {
		return fmt.Errorf("invalid scan configuration: %w", err)
	}

	ss.config = config

	ss.auditLogger.WithFields(map[string]interface{}{
		"operation":    "scan_config_updated",
		"scanner":      string(config.Scanner),
		"max_critical": config.MaxCritical,
		"max_high":     config.MaxHigh,
		"max_medium":   config.MaxMedium,
		"max_low":      config.MaxLow,
		"timeout":      config.Timeout.Seconds(),
		"timestamp":    time.Now().Unix(),
	}).Info("Security scanning configuration updated")

	return nil
}

// validateScanConfig validates security scanning configuration
func (ss *SecurityScanner) validateScanConfig(config *ScanConfig) error {
	// Validate scanner type
	validScanners := []VulnerabilityScanner{ScannerTrivy, ScannerClair}
	scannerValid := false
	for _, scanner := range validScanners {
		if config.Scanner == scanner {
			scannerValid = true
			break
		}
	}
	if !scannerValid {
		return fmt.Errorf("invalid scanner: %s", config.Scanner)
	}

	// Validate timeout
	if config.Timeout <= 0 {
		return fmt.Errorf("scan timeout must be positive, got: %v", config.Timeout)
	}

	// Validate vulnerability limits (cannot be negative)
	if config.MaxCritical < 0 {
		return fmt.Errorf("max critical vulnerabilities cannot be negative: %d", config.MaxCritical)
	}
	if config.MaxHigh < 0 {
		return fmt.Errorf("max high vulnerabilities cannot be negative: %d", config.MaxHigh)
	}
	if config.MaxMedium < 0 {
		return fmt.Errorf("max medium vulnerabilities cannot be negative: %d", config.MaxMedium)
	}
	if config.MaxLow < 0 {
		return fmt.Errorf("max low vulnerabilities cannot be negative: %d", config.MaxLow)
	}

	// Validate report format
	validFormats := []string{"json", "table", "sarif"}
	formatValid := false
	for _, format := range validFormats {
		if config.ReportFormat == format {
			formatValid = true
			break
		}
	}
	if !formatValid {
		return fmt.Errorf("invalid report format: %s", config.ReportFormat)
	}

	// Validate cache TTL
	if config.CacheResults && config.CacheTTL <= 0 {
		return fmt.Errorf("cache TTL must be positive when caching is enabled: %v", config.CacheTTL)
	}

	return nil
}

// GetScanConfig returns the current security scanning configuration
func (ss *SecurityScanner) GetScanConfig() *ScanConfig {
	return ss.config
}

// CheckScannerAvailability verifies that the configured scanner is available
func (ss *SecurityScanner) CheckScannerAvailability() error {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	var cmd *exec.Cmd
	switch ss.config.Scanner {
	case ScannerTrivy:
		cmd = exec.CommandContext(ctx, "trivy", "--version")
	case ScannerClair:
		// For Clair, we might check if the service is running
		return fmt.Errorf("Clair availability check not implemented")
	default:
		return fmt.Errorf("unknown scanner: %s", ss.config.Scanner)
	}

	output, err := cmd.CombinedOutput()
	if err != nil {
		ss.auditLogger.WithFields(map[string]interface{}{
			"operation": "scanner_availability_check_failed",
			"scanner":   string(ss.config.Scanner),
			"error":     err.Error(),
			"output":    string(output),
			"timestamp": time.Now().Unix(),
		}).Error("Scanner availability check failed")

		return fmt.Errorf("scanner %s is not available: %w, output: %s", ss.config.Scanner, err, string(output))
	}

	ss.auditLogger.WithFields(map[string]interface{}{
		"operation":       "scanner_availability_check_passed",
		"scanner":         string(ss.config.Scanner),
		"scanner_version": strings.TrimSpace(string(output)),
		"timestamp":       time.Now().Unix(),
	}).Info("Scanner availability verified")

	return nil
}
