package scanner

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/yenhunghuang/repo-onboarding-copilot/pkg/logger"
)

func TestNewSecurityScanner(t *testing.T) {
	tests := []struct {
		name        string
		auditLogger *logger.Logger
		wantErr     bool
		errMsg      string
	}{
		{
			name:        "valid logger",
			auditLogger: logger.New(),
			wantErr:     false,
		},
		{
			name:        "nil logger",
			auditLogger: nil,
			wantErr:     true,
			errMsg:      "audit logger cannot be nil",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ss, err := NewSecurityScanner(tt.auditLogger)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.errMsg)
				assert.Nil(t, ss)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, ss)

				// Verify default configuration
				config := ss.GetScanConfig()
				assert.Equal(t, ScannerTrivy, config.Scanner)
				assert.Equal(t, 10*time.Minute, config.Timeout)
				assert.Equal(t, 0, config.MaxCritical)
				assert.Equal(t, 5, config.MaxHigh)
				assert.Equal(t, 20, config.MaxMedium)
				assert.Equal(t, 100, config.MaxLow)
				assert.True(t, config.ScanOS)
				assert.True(t, config.ScanLibraries)
				assert.True(t, config.ScanSecrets)
				assert.True(t, config.GenerateReport)
				assert.Equal(t, "json", config.ReportFormat)
				assert.True(t, config.CacheResults)
				assert.Equal(t, 24*time.Hour, config.CacheTTL)
			}
		})
	}
}

func TestCategorizeVulnerabilities(t *testing.T) {
	auditLogger := logger.New()
	ss, err := NewSecurityScanner(auditLogger)
	require.NoError(t, err)

	result := &ScanResult{
		Vulnerabilities: []Vulnerability{
			{ID: "CVE-2023-0001", Severity: SeverityCritical},
			{ID: "CVE-2023-0002", Severity: SeverityCritical},
			{ID: "CVE-2023-0003", Severity: SeverityHigh},
			{ID: "CVE-2023-0004", Severity: SeverityHigh},
			{ID: "CVE-2023-0005", Severity: SeverityHigh},
			{ID: "CVE-2023-0006", Severity: SeverityMedium},
			{ID: "CVE-2023-0007", Severity: SeverityMedium},
			{ID: "CVE-2023-0008", Severity: SeverityLow},
			{ID: "CVE-2023-0009", Severity: SeverityUnknown},
		},
	}

	ss.categorizeVulnerabilities(result)

	assert.Equal(t, 9, result.TotalVulns)
	assert.Equal(t, 2, result.CriticalCount)
	assert.Equal(t, 3, result.HighCount)
	assert.Equal(t, 2, result.MediumCount)
	assert.Equal(t, 1, result.LowCount)
	assert.Equal(t, 1, result.UnknownCount)
}

func TestEvaluateSecurityPolicy(t *testing.T) {
	auditLogger := logger.New()
	ss, err := NewSecurityScanner(auditLogger)
	require.NoError(t, err)

	tests := []struct {
		name               string
		criticalCount      int
		highCount          int
		mediumCount        int
		lowCount           int
		expectedPolicyPass bool
		expectedViolations int
	}{
		{
			name:               "no vulnerabilities - pass",
			criticalCount:      0,
			highCount:          0,
			mediumCount:        0,
			lowCount:           0,
			expectedPolicyPass: true,
			expectedViolations: 0,
		},
		{
			name:               "within limits - pass",
			criticalCount:      0,
			highCount:          3,
			mediumCount:        15,
			lowCount:           50,
			expectedPolicyPass: true,
			expectedViolations: 0,
		},
		{
			name:               "critical vulnerabilities - fail",
			criticalCount:      2, // Max is 0
			highCount:          3,
			mediumCount:        15,
			lowCount:           50,
			expectedPolicyPass: false,
			expectedViolations: 1,
		},
		{
			name:               "high vulnerabilities exceed limit - fail",
			criticalCount:      0,
			highCount:          10, // Max is 5
			mediumCount:        15,
			lowCount:           50,
			expectedPolicyPass: false,
			expectedViolations: 1,
		},
		{
			name:               "multiple violations - fail",
			criticalCount:      1,   // Max is 0
			highCount:          10,  // Max is 5
			mediumCount:        25,  // Max is 20
			lowCount:           150, // Max is 100
			expectedPolicyPass: false,
			expectedViolations: 4,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := &ScanResult{
				CriticalCount: tt.criticalCount,
				HighCount:     tt.highCount,
				MediumCount:   tt.mediumCount,
				LowCount:      tt.lowCount,
			}

			ss.evaluateSecurityPolicy(result)

			assert.Equal(t, tt.expectedPolicyPass, result.PolicyPassed)
			assert.Len(t, result.PolicyViolations, tt.expectedViolations)

			// Verify violation details
			for _, violation := range result.PolicyViolations {
				assert.NotEmpty(t, violation.Rule)
				assert.NotEmpty(t, violation.Description)
				assert.Greater(t, violation.Count, violation.Limit)
			}
		})
	}
}

func TestValidateScanConfig(t *testing.T) {
	auditLogger := logger.New()
	ss, err := NewSecurityScanner(auditLogger)
	require.NoError(t, err)

	tests := []struct {
		name    string
		config  *ScanConfig
		wantErr bool
		errMsg  string
	}{
		{
			name: "valid config",
			config: &ScanConfig{
				Scanner:        ScannerTrivy,
				Timeout:        5 * time.Minute,
				MaxCritical:    0,
				MaxHigh:        5,
				MaxMedium:      20,
				MaxLow:         100,
				ScanOS:         true,
				ScanLibraries:  true,
				ScanSecrets:    false,
				GenerateReport: true,
				ReportFormat:   "json",
				CacheResults:   true,
				CacheTTL:       24 * time.Hour,
			},
			wantErr: false,
		},
		{
			name: "invalid scanner",
			config: &ScanConfig{
				Scanner:      "invalid-scanner",
				Timeout:      5 * time.Minute,
				MaxCritical:  0,
				MaxHigh:      5,
				MaxMedium:    20,
				MaxLow:       100,
				ReportFormat: "json",
				CacheTTL:     24 * time.Hour,
			},
			wantErr: true,
			errMsg:  "invalid scanner",
		},
		{
			name: "invalid timeout",
			config: &ScanConfig{
				Scanner:      ScannerTrivy,
				Timeout:      -1 * time.Minute,
				MaxCritical:  0,
				MaxHigh:      5,
				MaxMedium:    20,
				MaxLow:       100,
				ReportFormat: "json",
				CacheTTL:     24 * time.Hour,
			},
			wantErr: true,
			errMsg:  "scan timeout must be positive",
		},
		{
			name: "negative vulnerability limits",
			config: &ScanConfig{
				Scanner:      ScannerTrivy,
				Timeout:      5 * time.Minute,
				MaxCritical:  -1, // Invalid negative value
				MaxHigh:      5,
				MaxMedium:    20,
				MaxLow:       100,
				ReportFormat: "json",
				CacheTTL:     24 * time.Hour,
			},
			wantErr: true,
			errMsg:  "max critical vulnerabilities cannot be negative",
		},
		{
			name: "invalid report format",
			config: &ScanConfig{
				Scanner:      ScannerTrivy,
				Timeout:      5 * time.Minute,
				MaxCritical:  0,
				MaxHigh:      5,
				MaxMedium:    20,
				MaxLow:       100,
				ReportFormat: "invalid-format",
				CacheTTL:     24 * time.Hour,
			},
			wantErr: true,
			errMsg:  "invalid report format",
		},
		{
			name: "invalid cache TTL when caching enabled",
			config: &ScanConfig{
				Scanner:      ScannerTrivy,
				Timeout:      5 * time.Minute,
				MaxCritical:  0,
				MaxHigh:      5,
				MaxMedium:    20,
				MaxLow:       100,
				ReportFormat: "json",
				CacheResults: true,
				CacheTTL:     -1 * time.Hour, // Invalid negative TTL
			},
			wantErr: true,
			errMsg:  "cache TTL must be positive when caching is enabled",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ss.SetScanConfig(tt.config)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Contains(t, err.Error(), tt.errMsg)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}
