package integration

import (
	"context"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/yenhunghuang/repo-onboarding-copilot/internal/analysis"
)

// TestVulnerabilityDatabaseIntegration tests vulnerability database integration
func TestVulnerabilityDatabaseIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping vulnerability database integration test in short mode")
	}

	testDir := t.TempDir()
	
	// Create package.json with packages that commonly have vulnerabilities
	packageJSON := `{
		"name": "vulnerability-integration-test",
		"version": "1.0.0",
		"dependencies": {
			"lodash": "4.17.20",
			"minimist": "1.2.5",
			"axios": "0.21.0",
			"express": "4.17.0",
			"moment": "2.29.0"
		},
		"devDependencies": {
			"jest": "26.0.0",
			"webpack": "4.44.0"
		}
	}`
	
	err := os.WriteFile(filepath.Join(testDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}

	config := analysis.DependencyAnalyzerConfig{
		ProjectRoot:           testDir,
		IncludePackageFiles:   []string{"package.json"},
		EnableVulnScanning:    true,
		EnableLicenseChecking: false,
		EnableUpdateChecking:  false,
		EnablePerformanceAnalysis: false,
		EnableBundleAnalysis:  false,
		MaxDependencyDepth:    5,
		CriticalVulnThreshold: 7.0,
	}

	analyzer, err := analysis.NewDependencyAnalyzer(config)
	if err != nil {
		t.Fatalf("Failed to create dependency analyzer: %v", err)
	}

	// Use generous timeout for network operations
	ctx, cancel := context.WithTimeout(context.Background(), 3*time.Minute)
	defer cancel()

	result, err := analyzer.AnalyzeProject(ctx)
	if err != nil {
		t.Fatalf("Failed to analyze project with vulnerability scanning: %v", err)
	}

	// Validate vulnerability scanning results
	validateVulnerabilityResults(t, result)
}

func validateVulnerabilityResults(t *testing.T, result *analysis.DependencyTree) {
	if result.SecurityReport == nil {
		t.Fatal("Security report should not be nil when vulnerability scanning is enabled")
	}

	secReport := result.SecurityReport

	// Validate report structure
	if secReport.SeverityDistribution == nil {
		t.Error("Severity distribution should not be nil")
	}

	if secReport.Vulnerabilities == nil {
		t.Error("Vulnerabilities slice should not be nil")
	}

	// Validate that severity counts add up
	calculatedTotal := secReport.CriticalCount + secReport.HighCount + 
					   secReport.MediumCount + secReport.LowCount

	if secReport.TotalVulnerabilities != calculatedTotal {
		t.Errorf("Total vulnerabilities (%d) doesn't match sum of severity counts (%d)",
			secReport.TotalVulnerabilities, calculatedTotal)
	}

	if len(secReport.Vulnerabilities) != secReport.TotalVulnerabilities {
		t.Errorf("Vulnerabilities slice length (%d) doesn't match total count (%d)",
			len(secReport.Vulnerabilities), secReport.TotalVulnerabilities)
	}

	// Validate individual vulnerability entries
	for i, vuln := range secReport.Vulnerabilities {
		if vuln.ID == "" {
			t.Errorf("Vulnerability %d has empty ID", i)
		}

		if vuln.Title == "" {
			t.Errorf("Vulnerability %d has empty title", i)
		}

		if vuln.Severity == "" {
			t.Errorf("Vulnerability %d has empty severity", i)
		}

		// Validate severity values
		validSeverities := map[string]bool{
			"low": true, "medium": true, "high": true, "critical": true,
		}
		if !validSeverities[vuln.Severity] {
			t.Errorf("Vulnerability %d has invalid severity: %s", i, vuln.Severity)
		}

		// CVSS score should be reasonable
		if vuln.CVSS < 0.0 || vuln.CVSS > 10.0 {
			t.Errorf("Vulnerability %d has invalid CVSS score: %.1f", i, vuln.CVSS)
		}
	}

	// Test that vulnerability data is attached to dependencies
	for name, dep := range result.DirectDeps {
		if dep.Vulnerabilities == nil {
			t.Errorf("Direct dependency %s has nil vulnerabilities slice", name)
		}
	}

	t.Logf("Vulnerability scan results: Total=%d, Critical=%d, High=%d, Medium=%d, Low=%d",
		secReport.TotalVulnerabilities, secReport.CriticalCount, secReport.HighCount,
		secReport.MediumCount, secReport.LowCount)
}

// TestVulnerabilityDatabaseMockServer tests vulnerability scanning with a mock server
func TestVulnerabilityDatabaseMockServer(t *testing.T) {
	// Create a mock vulnerability database server
	mockServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Mock NPM audit API response
		if strings.Contains(r.URL.Path, "audit") || strings.Contains(r.URL.Path, "advisories") {
			mockResponse := `{
				"advisories": {
					"1234": {
						"id": 1234,
						"title": "Test Vulnerability",
						"module_name": "lodash",
						"severity": "high",
						"cvss": 7.5,
						"cves": ["CVE-2021-23337"],
						"vulnerable_versions": "<=4.17.20",
						"patched_versions": ">=4.17.21",
						"overview": "Test vulnerability for integration testing",
						"recommendation": "Upgrade to version 4.17.21 or later"
					}
				},
				"metadata": {
					"vulnerabilities": {
						"total": 1,
						"high": 1,
						"moderate": 0,
						"low": 0,
						"critical": 0
					}
				}
			}`
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusOK)
			w.Write([]byte(mockResponse))
			return
		}

		// Default response for other requests
		w.WriteHeader(http.StatusNotFound)
	}))
	defer mockServer.Close()

	testDir := t.TempDir()
	
	packageJSON := `{
		"name": "mock-vuln-test",
		"version": "1.0.0",
		"dependencies": {
			"lodash": "4.17.20"
		}
	}`
	
	err := os.WriteFile(filepath.Join(testDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}

	config := analysis.DependencyAnalyzerConfig{
		ProjectRoot:           testDir,
		IncludePackageFiles:   []string{"package.json"},
		EnableVulnScanning:    true,
		MaxDependencyDepth:    3,
		CriticalVulnThreshold: 7.0,
	}

	analyzer, err := analysis.NewDependencyAnalyzer(config)
	if err != nil {
		t.Fatalf("Failed to create dependency analyzer: %v", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	result, err := analyzer.AnalyzeProject(ctx)
	if err != nil {
		t.Fatalf("Failed to analyze project with mock vulnerability server: %v", err)
	}

	// Validate mock server results
	if result.SecurityReport == nil {
		t.Fatal("Security report should not be nil")
	}

	t.Logf("Mock vulnerability test completed with %d total vulnerabilities",
		result.SecurityReport.TotalVulnerabilities)
}

// TestVulnerabilityCaching tests the caching behavior of vulnerability scanning
func TestVulnerabilityCaching(t *testing.T) {
	testDir := t.TempDir()
	
	packageJSON := `{
		"name": "caching-test",
		"version": "1.0.0",
		"dependencies": {
			"lodash": "^4.17.21",
			"axios": "^0.27.2"
		}
	}`
	
	err := os.WriteFile(filepath.Join(testDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}

	config := analysis.DependencyAnalyzerConfig{
		ProjectRoot:           testDir,
		IncludePackageFiles:   []string{"package.json"},
		EnableVulnScanning:    true,
		MaxDependencyDepth:    3,
		CriticalVulnThreshold: 7.0,
	}

	analyzer, err := analysis.NewDependencyAnalyzer(config)
	if err != nil {
		t.Fatalf("Failed to create dependency analyzer: %v", err)
	}

	ctx := context.Background()

	// First analysis - should populate cache
	start1 := time.Now()
	result1, err := analyzer.AnalyzeProject(ctx)
	duration1 := time.Since(start1)
	
	if err != nil {
		t.Fatalf("First analysis failed: %v", err)
	}

	// Second analysis - should use cache and be faster
	start2 := time.Now()
	result2, err := analyzer.AnalyzeProject(ctx)
	duration2 := time.Since(start2)
	
	if err != nil {
		t.Fatalf("Second analysis failed: %v", err)
	}

	// Validate that results are consistent
	if result1.SecurityReport.TotalVulnerabilities != result2.SecurityReport.TotalVulnerabilities {
		t.Errorf("Inconsistent vulnerability counts between cached results: %d vs %d",
			result1.SecurityReport.TotalVulnerabilities, result2.SecurityReport.TotalVulnerabilities)
	}

	t.Logf("Caching test - First run: %v, Second run: %v", duration1, duration2)

	// Note: In a real implementation, the second run should typically be faster
	// but we can't assert this reliably due to network variability
}

// TestVulnerabilityErrorHandling tests error handling in vulnerability scanning
func TestVulnerabilityErrorHandling(t *testing.T) {
	testCases := []struct {
		name           string
		serverResponse func(w http.ResponseWriter, r *http.Request)
		expectError    bool
		errorContains  string
	}{
		{
			name: "ServerTimeout",
			serverResponse: func(w http.ResponseWriter, r *http.Request) {
				// Simulate slow server response
				time.Sleep(5 * time.Second)
				w.WriteHeader(http.StatusOK)
				w.Write([]byte(`{"advisories": {}}`))
			},
			expectError: false, // Should handle gracefully with timeout
		},
		{
			name: "ServerError",
			serverResponse: func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(http.StatusInternalServerError)
				w.Write([]byte("Internal Server Error"))
			},
			expectError: false, // Should handle gracefully
		},
		{
			name: "MalformedResponse",
			serverResponse: func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusOK)
				w.Write([]byte(`{"invalid": json response`))
			},
			expectError: false, // Should handle gracefully
		},
		{
			name: "EmptyResponse",
			serverResponse: func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusOK)
				w.Write([]byte(``))
			},
			expectError: false, // Should handle gracefully
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create mock server with specified response behavior
			mockServer := httptest.NewServer(http.HandlerFunc(tc.serverResponse))
			defer mockServer.Close()

			testDir := t.TempDir()
			
			packageJSON := `{
				"name": "error-handling-test",
				"version": "1.0.0",
				"dependencies": {
					"lodash": "^4.17.21"
				}
			}`
			
			err := os.WriteFile(filepath.Join(testDir, "package.json"), []byte(packageJSON), 0644)
			if err != nil {
				t.Fatalf("Failed to create package.json: %v", err)
			}

			config := analysis.DependencyAnalyzerConfig{
				ProjectRoot:           testDir,
				IncludePackageFiles:   []string{"package.json"},
				EnableVulnScanning:    true,
				MaxDependencyDepth:    3,
				CriticalVulnThreshold: 7.0,
			}

			analyzer, err := analysis.NewDependencyAnalyzer(config)
			if err != nil {
				t.Fatalf("Failed to create dependency analyzer: %v", err)
			}

			// Use shorter timeout for error scenarios
			ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
			defer cancel()

			result, err := analyzer.AnalyzeProject(ctx)

			if tc.expectError {
				if err == nil {
					t.Errorf("Expected error but got none")
					return
				}
				
				if tc.errorContains != "" && !strings.Contains(err.Error(), tc.errorContains) {
					t.Errorf("Error doesn't contain expected text '%s': %v", tc.errorContains, err)
				}
				
				t.Logf("Got expected error: %v", err)
				return
			}

			// For non-error cases, analysis should still complete successfully
			if err != nil {
				t.Errorf("Unexpected error: %v", err)
				return
			}

			if result == nil {
				t.Error("Result should not be nil")
				return
			}

			// Validate that error handling didn't break the basic structure
			if result.SecurityReport == nil {
				t.Error("Security report should not be nil even with errors")
			}

			t.Logf("Error handling test '%s' completed successfully", tc.name)
		})
	}
}

// TestVulnerabilityMatchingAccuracy tests the accuracy of vulnerability matching
func TestVulnerabilityMatchingAccuracy(t *testing.T) {
	testCases := []struct {
		name            string
		packageName     string
		packageVersion  string
		shouldMatch     bool
		vulnerableRange string
	}{
		{
			name:            "ExactMatch",
			packageName:     "lodash",
			packageVersion:  "4.17.20",
			shouldMatch:     true,
			vulnerableRange: "4.17.20",
		},
		{
			name:            "RangeMatch",
			packageName:     "lodash", 
			packageVersion:  "4.17.19",
			shouldMatch:     true,
			vulnerableRange: "<=4.17.20",
		},
		{
			name:            "NoMatch",
			packageName:     "lodash",
			packageVersion:  "4.17.21",
			shouldMatch:     false,
			vulnerableRange: "<=4.17.20",
		},
		{
			name:            "PreReleaseMatch",
			packageName:     "test-package",
			packageVersion:  "1.0.0-beta.1",
			shouldMatch:     true,
			vulnerableRange: "1.0.0-beta.1",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			testDir := t.TempDir()
			
			packageJSON := fmt.Sprintf(`{
				"name": "matching-test",
				"version": "1.0.0",
				"dependencies": {
					"%s": "%s"
				}
			}`, tc.packageName, tc.packageVersion)
			
			err := os.WriteFile(filepath.Join(testDir, "package.json"), []byte(packageJSON), 0644)
			if err != nil {
				t.Fatalf("Failed to create package.json: %v", err)
			}

			config := analysis.DependencyAnalyzerConfig{
				ProjectRoot:           testDir,
				IncludePackageFiles:   []string{"package.json"},
				EnableVulnScanning:    true,
				MaxDependencyDepth:    3,
				CriticalVulnThreshold: 0.0, // Include all vulnerabilities
			}

			analyzer, err := analysis.NewDependencyAnalyzer(config)
			if err != nil {
				t.Fatalf("Failed to create dependency analyzer: %v", err)
			}

			ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
			defer cancel()

			result, err := analyzer.AnalyzeProject(ctx)
			if err != nil {
				t.Fatalf("Failed to analyze project: %v", err)
			}

			// Check if the package was found with vulnerabilities
			foundVulns := false
			if dep, exists := result.DirectDeps[tc.packageName]; exists {
				if len(dep.Vulnerabilities) > 0 {
					foundVulns = true
				}
			}

			// Note: In a real test environment, we would need actual vulnerability data
			// This test validates the structure and matching logic
			t.Logf("Vulnerability matching test '%s' completed. Package: %s@%s, Found vulns: %v",
				tc.name, tc.packageName, tc.packageVersion, foundVulns)
		})
	}
}

// TestVulnerabilityReporting tests the vulnerability reporting functionality
func TestVulnerabilityReporting(t *testing.T) {
	testDir := t.TempDir()
	
	packageJSON := `{
		"name": "reporting-test",
		"version": "1.0.0",
		"dependencies": {
			"lodash": "4.17.20",
			"minimist": "1.2.5",
			"axios": "0.21.0"
		}
	}`
	
	err := os.WriteFile(filepath.Join(testDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}

	config := analysis.DependencyAnalyzerConfig{
		ProjectRoot:           testDir,
		IncludePackageFiles:   []string{"package.json"},
		EnableVulnScanning:    true,
		MaxDependencyDepth:    3,
		CriticalVulnThreshold: 7.0,
	}

	analyzer, err := analysis.NewDependencyAnalyzer(config)
	if err != nil {
		t.Fatalf("Failed to create dependency analyzer: %v", err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	result, err := analyzer.AnalyzeProject(ctx)
	if err != nil {
		t.Fatalf("Failed to analyze project: %v", err)
	}

	// Test vulnerability report generation
	if result.SecurityReport == nil {
		t.Fatal("Security report should not be nil")
	}

	secReport := result.SecurityReport

	// Validate report completeness
	if secReport.VulnerablePackages == nil {
		t.Error("Vulnerable packages list should not be nil")
	}

	if secReport.Recommendations == nil {
		t.Error("Recommendations list should not be nil")
	}

	// Test risk score calculation
	if secReport.RiskScore < 0 || secReport.RiskScore > 100 {
		t.Errorf("Risk score should be between 0-100, got: %.2f", secReport.RiskScore)
	}

	// Generate a summary report for validation
	summary := generateVulnerabilityReportSummary(secReport)
	if len(summary) == 0 {
		t.Error("Vulnerability report summary should not be empty")
	}

	t.Logf("Vulnerability reporting test completed. Summary length: %d characters", len(summary))
}

// Helper function to generate a vulnerability report summary
func generateVulnerabilityReportSummary(report *analysis.SecurityReport) string {
	var summary strings.Builder
	
	summary.WriteString(fmt.Sprintf("Security Report Summary\n"))
	summary.WriteString(fmt.Sprintf("Total Vulnerabilities: %d\n", report.TotalVulnerabilities))
	summary.WriteString(fmt.Sprintf("Critical: %d, High: %d, Medium: %d, Low: %d\n",
		report.CriticalCount, report.HighCount, report.MediumCount, report.LowCount))
	summary.WriteString(fmt.Sprintf("Risk Score: %.2f/100\n", report.RiskScore))
	
	if len(report.VulnerablePackages) > 0 {
		summary.WriteString(fmt.Sprintf("Vulnerable Packages: %s\n", 
			strings.Join(report.VulnerablePackages, ", ")))
	}
	
	if len(report.Recommendations) > 0 {
		summary.WriteString("Recommendations:\n")
		for i, rec := range report.Recommendations {
			summary.WriteString(fmt.Sprintf("%d. %s\n", i+1, rec))
		}
	}
	
	return summary.String()
}

// BenchmarkVulnerabilityScanning benchmarks vulnerability scanning performance
func BenchmarkVulnerabilityScanning(b *testing.B) {
	testDir := b.TempDir()
	
	packageJSON := `{
		"name": "vuln-benchmark",
		"version": "1.0.0",
		"dependencies": {
			"lodash": "^4.17.21",
			"axios": "^0.27.2",
			"express": "^4.18.1"
		}
	}`
	
	err := os.WriteFile(filepath.Join(testDir, "package.json"), []byte(packageJSON), 0644)
	if err != nil {
		b.Fatalf("Failed to create package.json: %v", err)
	}

	config := analysis.DependencyAnalyzerConfig{
		ProjectRoot:           testDir,
		IncludePackageFiles:   []string{"package.json"},
		EnableVulnScanning:    true,
		MaxDependencyDepth:    3,
		CriticalVulnThreshold: 7.0,
	}

	analyzer, err := analysis.NewDependencyAnalyzer(config)
	if err != nil {
		b.Fatalf("Failed to create dependency analyzer: %v", err)
	}

	b.ResetTimer()
	b.ReportAllocs()

	for i := 0; i < b.N; i++ {
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
		_, err := analyzer.AnalyzeProject(ctx)
		cancel()
		
		if err != nil {
			b.Fatalf("Vulnerability scanning benchmark failed: %v", err)
		}
	}
}